# -*- encoding:utf-8 Mode: POLY-ORG; tab-width: 2; org-src-preserve-indentation: t; -*- ---
#+TITLE:  Literate programming tool write smalltalk in org mode.
#+SubTitle: inspired by shampoo.
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+LATEX_HEADER: % copied from lstlang1.sty, to add new language support to Emacs Lisp.
#+LATEX_HEADER: \lstdefinelanguage{elisp}[]{lisp} {}
#+LATEX_HEADER: \lstloadlanguages{elisp}
#+PROPERTY: header-args
#+PROPERTY: literate-lang elisp
#+PROPERTY: literate-load yes

* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#preparation][Preparation]]
- [[#how-to-do-it-01][How to do it?]]
- [[#emacs-side][Emacs side]]
  - [[#code-mode][code mode]]
  - [[#utilities][utilities]]
    - [[#valid-side][valid side]]
    - [[#forward-to-begin-of-function][forward to begin of function]]
    - [[#current-symbol-at-point][current symbol at point]]
    - [[#previous-symbol-at-point][previous symbol at point]]
  - [[#apis][APIs]]
    - [[#api-request][api request]]
    - [[#get-namespaces][get namespaces]]
    - [[#get-classes-of-one-namespace][get classes of one namespace]]
    - [[#cache-for-classes-as-index][cache for classes as index]]
    - [[#get-namespace-of-one-class][get namespace of one class]]
    - [[#print-out-class-definition][print out class definition]]
    - [[#get-class-definition][get class definition]]
    - [[#get-categories-of-one-class][get categories of one class]]
    - [[#get-methods-of-one-category][get methods of one category]]
    - [[#get-method-source][get method source]]
    - [[#eval-code][eval code]]
    - [[#prarse-a-regex][prarse a regex]]
    - [[#how-to-parse-a-class-message][how to parse a class message]]
    - [[#parse-class-definition][parse class definition]]
    - [[#parse-subclass-definition][parse subclass definition]]
    - [[#compile-class][compile class]]
    - [[#compile-method][compile method]]
    - [[#format-code][format code]]
    - [[#search-a-pattern-in-a-buffer-and-return-its-position][search a pattern in a buffer and return its position]]
    - [[#find-definition-of-class-in-org-files][find definition of class in org files]]
    - [[#find-definition-of-a-class-method-in-org-files][find definition of a class method in org files]]
  - [[#fetch-all-source-of-a-package-to-an-org-section][Fetch all source of a package to an org section.]]
  - [[#update-codes][update codes]]
  - [[#jump-to-implementations][jump to implementations.]]
    - [[#basic-idea][basic idea]]
    - [[#xref-interfaces][xref interfaces]]
    - [[#implementation][implementation]]
  - [[#babel-support][babel support]]
    - [[#optionally-define-a-file-extension-for-this-language][optionally define a file extension for this language]]
    - [[#optionally-declare-default-header-arguments][optionally declare default header arguments]]
    - [[#source-code-execution][Source Code Execution]]
  - [[#code-format][code format]]
  - [[#shortcut][shortcut]]
  - [[#test][Test]]
    - [[#eval-codes][eval codes]]
- [[#pharo-side][Pharo side]]
  - [[#baseline][baseline]]
    - [[#definition][definition]]
    - [[#spec][spec]]
  - [[#a-teapot-server-to-handle-request][a Teapot server to handle request]]
    - [[#definition-1][definition]]
    - [[#the-server-accessor][the Server accessor]]
    - [[#start-the-routes][start the routes]]
    - [[#asstringarray][asStringArray:]]
    - [[#elementsstring][elementsString]]
    - [[#get-namespaces-1][get namespaces]]
    - [[#get-classes-of-one-namespace-1][get classes of one namespace]]
    - [[#get-class-information][get class information]]
    - [[#get-class-categories][get class categories]]
    - [[#get-methods-in-one-class-category][get methods in one class category]]
    - [[#get-method-source-1][get method source]]
    - [[#eval-code-1][eval code]]
    - [[#compile-class-1][compile class]]
    - [[#compile-method-1][compile method]]
    - [[#format-code-1][format code]]

* Introduction
This is an attemp to write smalltalk codes in org mode,
and interact with remote [[https://pharo.org/][pharo]] images inspired from [[https://github.com/dmatveev/shampoo-emacs][shampoo]]([[https://github.com/jingtaozf/shampoo-pharo.git][shampo for pharo]]).
* Preparation
You need to install pharo side codes in pharo and start server by the following codes
#+begin_src st
LiterateServer start.
#+end_src
* How to do it? [0/1]
We interact with pharo via shampoo, and hack shampoo to fetch/update codes in an org file.

- [ ] Find packages's sub category
  https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Extensions.md#define-an-extension-method-programmatically

* Emacs side
** code mode
inspired from shampoo-code-mode
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-binsel "\\([-+*/~,<>=&?]\\{1,2\\}\\|:=\\|||\\)"
  "Smalltalk binary selectors")

(defconst literate-smalltalk-smalltalk-font-lock-keywords
  (list
   '("#[A-z][A-z0-9_]*"          . font-lock-constant-face)
   '("\\<[A-z][A-z0-9_]*:"       . font-lock-function-name-face)
   (cons literate-smalltalk-smalltalk-binsel 'font-lock-function-name-face)
   '("\\$."                      . font-lock-string-face)
   '("\\<[A-Z]\\sw*\\>"          . font-lock-type-face)
   '("[0-9]+"                    . font-lock-constant-face))
  "Basic Smalltalk keywords font-locking")

(defconst literate-smalltalk-smalltalk-font-lock-keywords-1
  literate-smalltalk-smalltalk-font-lock-keywords
  "Level 1 Smalltalk font-locking keywords")

(defconst literate-smalltalk-smalltalk-font-lock-keywords-2
  (append literate-smalltalk-smalltalk-font-lock-keywords-1
	  (list
	   '("\\<\\(true\\|false\\|nil\\|self\\|super\\)\\>"
	     . font-lock-builtin-face)
	   '(":[a-z][A-z0-9_]*" . font-lock-variable-name-face)
	   '(" |"               . font-lock-type-face)
	   '("<.*>"             . font-lock-builtin-face)))
  "Level 2 Smalltalk font-locking keywords")

(defconst literate-smalltalk-smalltalk-font-lock-keywords-list
  '((literate-smalltalk-smalltalk-font-lock-keywords
     literate-smalltalk-smalltalk-font-lock-keywords-1
     literate-smalltalk-smalltalk-font-lock-keywords-2)))

(defvar literate-smalltalk-smalltalk-mode-syntax-table
  (let ((table (make-syntax-table)))
    ;; Make sure A-z0-9 are set to "w   " for completeness
    (let ((c 0))
      (setq c ?0)
      (while (<= c ?9)
	(setq c (1+ c))
	(modify-syntax-entry c "w   " table))
      (setq c ?A)
      (while (<= c ?Z)
	(setq c (1+ c))
	(modify-syntax-entry c "w   " table))
      (setq c ?a)
      (while (<= c ?z)
	(setq c (1+ c))
	(modify-syntax-entry c "w   " table)))
    (modify-syntax-entry 10  " >  " table) ; Comment (generic)
    (modify-syntax-entry ?:  ".   " table) ; Symbol-char
    (modify-syntax-entry ?_  "_   " table) ; Symbol-char
    (modify-syntax-entry ?\" "!1  " table) ; Comment (generic)
    (modify-syntax-entry ?'  "\"  " table) ; String
    (modify-syntax-entry ?#  "'   " table) ; Symbol or Array constant
    (modify-syntax-entry ?\( "()  " table) ; Grouping
    (modify-syntax-entry ?\) ")(  " table) ; Grouping
    (modify-syntax-entry ?\[ "(]  " table) ; Block-open
    (modify-syntax-entry ?\] ")[  " table) ; Block-close
    (modify-syntax-entry ?{  "(}  " table) ; Array-open
    (modify-syntax-entry ?}  "){  " table) ; Array-close
    (modify-syntax-entry ?$  "/   " table) ; Character literal
    (modify-syntax-entry ?!  ".   " table) ; End message / Delimit defs
    (modify-syntax-entry ?\; ".   " table) ; Cascade
    (modify-syntax-entry ?|  ".   " table) ; Temporaries
    (modify-syntax-entry ?^  ".   " table) ; Return
    ;; Just to make sure these are not set to "w   "
    (modify-syntax-entry ?<  ".   " table)
    (modify-syntax-entry ?>  ".   " table)
    (modify-syntax-entry ?+  ".   " table) ; math
    (modify-syntax-entry ?-  ".   " table) ; math
    (modify-syntax-entry ?*  ".   " table) ; math
    (modify-syntax-entry ?/  ".2  " table) ; math
    (modify-syntax-entry ?=  ".   " table) ; bool/assign
    (modify-syntax-entry ?%  ".   " table) ; valid selector
    (modify-syntax-entry ?&  ".   " table) ; boolean
    (modify-syntax-entry ?\\ ".   " table) ; ???
    (modify-syntax-entry ?~  ".   " table) ; misc. selector
    (modify-syntax-entry ?@  ".   " table) ; Point
    (modify-syntax-entry ?,  ".   " table) ; concat
    table)
  "Syntax table used by Smalltalk mode")

(define-derived-mode literate-smalltalk-code-mode
    text-mode "Literate Smalltalk code"
    (set (make-local-variable 'font-lock-defaults)
         literate-smalltalk-smalltalk-font-lock-keywords-list)
    (set-syntax-table literate-smalltalk-smalltalk-mode-syntax-table))

(setq auto-mode-alist (append '(("\\.st\\'" . literate-smalltalk-code-mode)) auto-mode-alist))
#+END_SRC

** utilities
*** valid side
#+BEGIN_SRC elisp
(defvar literate-smalltalk-valid-sides '(:class :instance))
(defun literate-smalltalk-side-sym-as-param (sym)
  (cdr (assoc sym '((:instance . "instance")
                    (:class    . "class")))))
#+END_SRC
*** forward to begin of function
#+BEGIN_SRC elisp
(defun literate-smalltalk-beginning-of-defun-function (arg)
  (if (> arg 0)
    (progn
      (search-backward "#+BEGIN_SRC ")
      (forward-line))
    (literate-smalltalk-end-of-defun-function)))

(defun literate-smalltalk-end-of-defun-function (arg)
  (search-forward "#+END_SRC")
  (forward-line -1))

(defun install-literate-smalltalk-beginning-of-defun-function ()
  (make-local-variable 'beginning-of-defun-function)
  (make-local-variable 'end-of-defun-function)
  (setf beginning-of-defun-function 'literate-smalltalk-beginning-of-defun-function)
  (setf end-of-defun-function 'literate-smalltalk-end-of-defun-function)
  )
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-beginning-of-defun-function)
#+END_SRC
*** current symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-at-point ()
  (save-excursion
    (let* ((beg (re-search-backward "[ \t\n(^[]" nil t))
           (end (progn
                  (forward-char)
                  (re-search-forward "[ \t\n\.]" nil t)
                  (backward-char)
                  (point))))
      (string-trim (buffer-substring-no-properties beg end) "[ \t\n\r(^]+"))))
#+END_SRC
*** previous symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-previous-symbol-at-point ()
  (save-excursion
    (re-search-backward "[ \t\n]" nil t)
    (forward-word -1)
    (literate-smalltalk-current-symbol-at-point)))
#+END_SRC

** APIs
*** api request
#+BEGIN_SRC elisp
(defvar literate-smalltalk-rest-server "http://localhost:9092/")
(defvar literate-smalltalk-last-response nil)
(cl-defun literate-smalltalk-request (path &key params data (type "GET"))
  (let ((resp nil))
    (request (concat literate-smalltalk-rest-server path)
        :params params
        :parser 'json-read
        :type type
        :sync t
        :data data
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-smalltalk-last-response response)
                     (unless (equal 200 (request-response-status-code response))
                       (error "Failed to request to remote pharo:%s" response))
                     (setf resp (request-response-data response)))))
    resp))
#+END_SRC
*** get namespaces
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespaces ()
  (cdr (assoc 'namespaces (literate-smalltalk-request "namespaces"))))

(defun literate-smalltalk-select-namespace ()
  (helm-select-list "Please select a namespace: " (literate-smalltalk-namespaces)))
#+END_SRC
*** get classes of one namespace
#+BEGIN_SRC elisp
(defun literate-smalltalk-classes (namespace)
  (mapcar 'identity
          (cdr (assoc 'classes (literate-smalltalk-request (concat "classes/" namespace))))))

(defun literate-smalltalk-select-a-class (namespace)
  (helm-select-list "Please select a namespace: " (literate-smalltalk-classes namespace)))
#+END_SRC
*** cache for classes as index
It is slow to build such indexed from remote pharo, let store it to a global variable and cache it to local file.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-indexed-classes-file "~/.emacs.d/smalltalk.classes.txt")
(defvar literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
(defun literate-smalltalk-index-classes ()
  (interactive)
  (loop for namespace in (literate-smalltalk-namespaces)
        do (message "Indexing %s" namespace)
           (loop for class in (literate-smalltalk-classes namespace)
                 do (setf (gethash class literate-smalltalk-indexed-classes) namespace)))
  (with-current-buffer (find-file-noselect literate-smalltalk-indexed-classes-file)
    (erase-buffer)
    (fundamental-mode)
    (maphash (lambda (k v)
               (insert k " " v "\n"))
             literate-smalltalk-indexed-classes)
    (save-buffer)
    (kill-current-buffer)))

(defun literate-smalltalk-restore-indexed-classes ()
  (interactive)
  (message "start restoring...")
  (setf literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
  (cl-loop for line in (s-split "\n" (f-read literate-smalltalk-indexed-classes-file) t)
           for items = (s-split " " line)
           do (setf (gethash (car items) literate-smalltalk-indexed-classes) (second items)))
  (message "restoring...done"))
#+END_SRC
*** get namespace of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-of-a-class (class)
  (when (= 0 (hash-table-count literate-smalltalk-indexed-classes))
    (error "Please build the cache before use namespace of a class."))
  (gethash class literate-smalltalk-indexed-classes))

(defun literate-smalltalk-namespace-of-current-symbol ()
  (interactive)
  (let ((class (thing-at-point 'symbol)))
    (message "%s's namespace is %s" class (literate-smalltalk-namespace-of-a-class class))))
#+END_SRC

*** print out class definition
#+BEGIN_SRC elisp
(defconst literate-smalltalk-class-template
  '(("instanceVariableNames:" . instvars)
    ("classVariableNames:"    . classvars)
    ;; ("poolDictionaries:"      . poolvars)
    ))

(defconst literate-smalltalk-class-side-template
  '(("instanceVariableNames:" . instvars)))
(defvar literate-smalltalk-separator "----------------------")

(defun literate-smalltalk-class-definition-string (resp)
  (let ((instance (cdr (assoc 'instance resp)))
        (class (cdr (assoc 'class resp))))
    (with-temp-buffer
      (insert
       (format "%s subclass: #%s"
               (cdr (assoc 'superclass instance))
               (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (insert (format
               "    package: '%s'"
               (cdr (assoc 'package instance))))
      (newline)
      (insert literate-smalltalk-separator)
      (newline)

      (insert (format "%s class" (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-side-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (trim-string (buffer-string)))))
#+END_SRC
*** get class definition
#+BEGIN_SRC elisp
(defun literate-smalltalk-class (class)
  (literate-smalltalk-class-definition-string (literate-smalltalk-request (concat "class/" class))))
#+END_SRC

*** get categories of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-categories (class)
  (literate-smalltalk-request (concat "cats/" class)))

;; (defun literate-smalltalk-select-a-category (namespace class)
;;   (helm-select-list "Please select a namespace: " (literate-smalltalk-categories namespace class)))
#+END_SRC
*** get methods of one category
#+BEGIN_SRC elisp
(defun literate-smalltalk-category-methods (class category side)
  (mapcar 'identity
          (cdr (assoc 'methods (literate-smalltalk-request "cat/methods"
                                                           :params `(("class" . ,class)
                                                                     ("cat" . ,category)
                                                                     ("side" . ,side)))))))
#+END_SRC
*** get method source
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-source (class method side)
  (let ((source (cdr (assoc 'source (literate-smalltalk-request
                                     "method/source"
                                     :params `(("class" . ,class)
                                               ("name" . ,method)
                                               ("side" . ,side)))))))
    (decode-coding-string source 'latin-1)))
#+END_SRC
*** eval code
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval (code)
  (let ((resp (literate-smalltalk-request
                                     "eval"
                                     :type "POST"
                                     :params `(("code" . ,code)))))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'result resp))
      (error "Failed to eval code!"))))
#+END_SRC
*** prarse a regex
#+BEGIN_SRC elisp
(defvar literate-smalltalk-regexp-tokens
    '((:Wd "\\([A-z]+[0-9]*\\)")
      (:Ws "\\([A-z 0-9]*\\)")
      (:Wa "\\([A-z\\.0-9]*\\)")
      (:Wc "\\([A-z\-0-9]*\\)")
      (:D  "\\([0-9]*\\)")
      (:sp "[\s\t\n]*")
      (:cr "\r")
      (:lf "\n")))

(defun literate-smalltalk-regexp-is-capture-token (sym)
  (let ((pattern (assoc sym literate-smalltalk-regexp-tokens)))
    (and (symbolp sym)
         pattern
         (string-match "^\\\\\(.*\\\\\)$" (cadr pattern)))))

(defun literate-smalltalk-regexp-parse (str pattern)
  (let ((regexp (reduce 'concat
                        (loop for each in pattern collect
                                                  (let ((re (assoc each literate-smalltalk-regexp-tokens)))
                                                    (if re (cadr re) each)))))
        (re-len (loop for each in pattern
                      sum (if (literate-smalltalk-regexp-is-capture-token each) 1 0))))
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (when (re-search-forward regexp nil t)
        (loop for i from 1 to re-len collect
              (match-string i))))))

(defun literate-smalltalk-regexp-parse-and-bind (str pattern bindings binder)
  (let ((parsed (literate-smalltalk-regexp-parse str pattern)))
    (when parsed
      (loop for binding in bindings for j from 0 do
        (funcall
          binder
          binding
          (nth j parsed)))
      t)))
#+END_SRC

*** how to parse a class message
#+BEGIN_SRC elisp
(cl-defun literate-smalltalk-parse-message (&key code pattern bindings to-split)
  (lexical-let ((data '()))
    (let* ((binder #'(lambda (key value)
                       (push (cons key value) data)))
           (%split-string #'(lambda (string)
                              (if (null string)
                                '()
                                (remove-if (lambda (x) (equal x "")) (split-string string "\s"))))))
      (if (literate-smalltalk-regexp-parse-and-bind code pattern bindings binder)
        (progn
          (dolist (k to-split)
            (let ((string (cdr (assoc k data))))
              (setf (cdr (assoc k data))
                      (if (null string) '()
                        (remove-if (lambda (x) (equal x "")) (funcall %split-string string))))))
          data)
        (progn (message "literate smalltalk: syntax error")
               nil)))))
#+END_SRC

*** parse class definition
#+BEGIN_SRC elisp
(defvar literate-smalltalk-class-side-pattern
    '(:Wd :sp "class" :sp "instanceVariableNames:" :sp "'" :Ws "'"))
(defun literate-smalltalk-parse-class-definition (code)
  (literate-smalltalk-parse-message
   :code code
   :pattern literate-smalltalk-class-side-pattern
   :bindings '(:name :instvars)
   :to-split '(:instvars)))
#+END_SRC
*** parse subclass definition
#+BEGIN_SRC elisp
(defvar literate-smalltalk-subclass-pattern
    '(:Wa :sp "subclass:" :sp "#" :Wd
      :sp "instanceVariableNames:" :sp "'" :Ws "'"
      :sp "classVariableNames:"    :sp "'" :Ws "'"
      ;; :sp "poolDictionaries:"      :sp "'" :Ws "'"
      :sp "package:"              :sp "'" :Wd "'"
      ))
(defun literate-smalltalk-parse-subclass-definition (code)
  (literate-smalltalk-parse-message
   :code code
   :pattern literate-smalltalk-subclass-pattern
   :bindings '(:super :name :instvars :classvars :package)
   :to-split '(:instvars :classvars)))
#+END_SRC

*** compile class
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-class (code)
  (let* ((code-parts
           (with-temp-buffer
             (insert code)
             (goto-char (point-min))
             (search-forward literate-smalltalk-separator)
             (let ((subclass-end-pos (line-beginning-position))
                   (class-start-pos (line-end-position)))
               (cons (buffer-substring-no-properties (point-min) subclass-end-pos)
                     (buffer-substring-no-properties class-start-pos (point-max))))))
         (instance-data (literate-smalltalk-parse-subclass-definition (first code-parts)))
         (class-data (literate-smalltalk-parse-class-definition (cdr code-parts))))
    (unless (and instance-data class-data)
      (error "Failed to get class information."))
    ;; (message "instance-data:'%s', class-data: '%s'" instance-data class-data)
    (let ((resp (literate-smalltalk-request
                 "compile/class"
                 :params `(("instance" . ,(json-encode instance-data))
                           ("class" . ,(json-encode class-data)))
                 :type "POST")))
      (message "Compile class %s." (cdr (assoc 'status resp))))))
#+END_SRC
*** compile method
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-method (ns class side category code)
  (let ((resp (literate-smalltalk-request
               "compile/method"
               :params `(("class" . ,class)
                       ("category" . ,category)
                       ("source" . ,code)
                       ("side" . ,(literate-smalltalk-side-sym-as-param side)))
               :type "POST")))
    (message "Compile method %s." (cdr (assoc 'result resp)))
    ))
#+END_SRC
*** format code
[[file:~/projects/smalltalk/pharo/src/Deprecated80/PluggableTextMorph.class.st::tree := RBParser parseMethod: source onError: \[ :msg :pos | ^ self \].][RBParser parseMethod]]
#+BEGIN_SRC elisp
(defun literate-smalltalk-format-code (code)
  (let ((resp (literate-smalltalk-request
               "format/code"
               :params `(("source" . ,(encode-coding-string code 'latin-1)))
               :type "POST")))
    (unless (string= "success" (cdr (assoc 'status resp)))
      (error "Failed to format code!"))
    (decode-coding-string (cdr (assoc 'source resp)) 'latin-1)))

#+END_SRC

*** search a pattern in a buffer and return its position
#+BEGIN_SRC elisp
(defvar literate-smalltalk-libraries-literate-path "~/Pharo/literate/")
(defun literate-smalltalk-search-pattern (pattern)
  (save-restriction
    (loop for buf in (cons (current-buffer)
                           (mapcar 'find-file-noselect (directory-files literate-smalltalk-libraries-literate-path t ".org$")))
          do (with-current-buffer buf
               (save-excursion
                 (goto-char (point-min))
                 (when (re-search-forward pattern nil t)
                   (goto-char (line-beginning-position))
                   (org-ensure-point-visible)
                   (return (list (current-buffer) (point)))))))))
#+END_SRC

*** find definition of class in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-class-definition (class-name)
  (literate-smalltalk-search-pattern (format "subclass: #%s" class-name)))
#+END_SRC
*** find definition of a class method in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-method-definition (class-name method-name)
  (literate-smalltalk-search-pattern (format ":type method :class %s.*\n%s" class-name method-name)))
#+END_SRC

** Fetch all source of a package to an org section.
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-to-org-section (&optional namespaces)
  (interactive)
  (let ((namespaces (or namespaces (literate-smalltalk-select-namespace))))
    (unless (listp namespaces)
      (setf namespaces (list namespaces)))
    (cl-loop for namespace in namespaces
             do (insert "\n* PACKAGE " namespace "\n")
             (loop for class in (literate-smalltalk-classes namespace)
                   for categories-dict = (literate-smalltalk-categories class)
                   do (insert "** CLASS " class "\n")
                      (insert "*** CLASS DEFINITION \n")
                      (insert "#+BEGIN_SRC st :type class \n")
                      (insert (literate-smalltalk-class class))
                      (insert "\n#+END_SRC\n")
                      (loop for side in literate-smalltalk-valid-sides
                            for side-symbol = (intern (subseq (symbol-name side) 1))
                            for side-name = (literate-smalltalk-side-sym-as-param side)
                            do (loop for category across (cdr (assoc side-symbol categories-dict))
                                     for normalized-category = (replace-regexp-in-string
                                                                       " " "@" category)
                                     do (loop for method in (literate-smalltalk-category-methods
                                                                     class category side-name)
                                              do (insert "*** METHOD "
                                                         method "                                            "
                                                                (symbol-name side)
                                                         ":" normalized-category ":" "\n")
                                                 (insert "#+BEGIN_SRC st :type method"
                                                         " :class " class
                                                         " :side " side-name
                                                         " :cat \"" category "\""
                                                         "\n")
                                                 (insert (literate-smalltalk-method-source
                                                                  class method side-name))
                                                 (insert "\n#+END_SRC\n")
                                                 (sit-for 0)))))
             (message "namedspace '%s' has been added." namespace))))
#+END_SRC
** update codes
#+BEGIN_SRC elisp
(defun literate-smalltalk-update-source ()
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (params (nth 2 info))
         (type (intern (concat ":" (cdr (assq :type params)))))
         (side (if (cdr (assq :side params))
                 (intern (concat ":" (cdr (assq :side params))))
                 :instance))
         (code (case type
                 (:method
                     (literate-smalltalk-method-source
                      (cdr (assq :class params))
                      (cdr (assq :name params))
                      side))
                 (:class
                  (literate-smalltalk-class (cdr (assq :name params))))
                 (t
                  (error "Unknown supported type %s" type))))
         (body (and code (decode-coding-string code 'latin-1))))
    (when body
      (let ((block-info (second (org-element-context))))
        (replace-region-contents (plist-get block-info :begin)
                                 (plist-get block-info :end)
                                 (lambda ()
                                   (let* ((beg-src-line (progn (goto-char (point-min))
                                                               (buffer-substring-no-properties
                                                                (line-beginning-position)
                                                                (line-end-position)))))
                                     (concat beg-src-line "\n"
                                             body "\n"
                                             "#+END_SRC\n"))))))))
#+END_SRC
** jump to implementations.
*** basic idea
We will try to use [[http://geoff.greer.fm/ag/][silver searcher]] as the xref backend to search.
#+BEGIN_SRC elisp
(defun literate-smalltalk-xref-backend ()
  'xref-st)

(defun install-literate-smalltalk-xref-backend ()
  (make-local-variable 'xref-backend-functions)
  (setf xref-backend-functions '(literate-smalltalk-xref-backend)))
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-xref-backend)
#+END_SRC
*** xref interfaces
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-identifier-at-point ((_backend (eql xref-st)))
  (literate-smalltalk-current-symbol-at-point))

(cl-defmethod xref-backend-definitions ((_backend (eql xref-st)) symbol)
  (literate-smalltalk--xref-find-definitions symbol))
#+END_SRC
*** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk--xref-find-definitions (name)
  (interactive)
  (let* ((class? (<= ?A (aref name 0) ?Z))
         (class-name (unless class?
                       (literate-smalltalk-previous-symbol-at-point)))
         (buf-pos (if class?
                    (literate-smalltalk-find-class-definition name)
                    (literate-smalltalk-find-method-definition class-name name))))
    (when buf-pos
      (list (xref-make (if class?
                         name
                         (concat class-name ">>" name))
                       (xref-make-buffer-location (first buf-pos)
                                                (second buf-pos)))))))
#+END_SRC

** babel support
*** optionally define a file extension for this language
#+BEGIN_SRC elisp
(add-to-list 'org-babel-tangle-lang-exts '("st" . "st"))
#+END_SRC
*** optionally declare default header arguments
#+BEGIN_SRC elisp
(defvar org-babel-default-header-args:st '())
#+END_SRC
*** Source Code Execution
**** babel entry
This is the main function which is called to evaluate a code block.

This function will evaluate the body of the source code and
return the results as emacs-lisp depending on the value of the
=:results= header argument

All header arguments specified by the user will be available in the =PARAMS= variable.
#+BEGIN_SRC elisp
(defun org-babel-execute:st (body params)
  "Execute a block of smalltalk code with org-babel.
This function is called by `org-babel-execute-src-block',
Argument BODY: the code body
Argument PARAMS: the input parameters."
  (let* ((result-params (cdr (assq :result-params params)))
         (results (literate-smalltalk-execute-code-block body params)))
    (when results
      (org-babel-result-cond result-params
        results
        (let ((tmp-file (org-babel-temp-file "q-")))
          (with-temp-file tmp-file (insert results))
          (org-babel-import-elisp-from-file tmp-file))))))
#+END_SRC
**** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-code-block (body params)
  (let ((type (intern (concat ":" (cdr (assq :type params)))))
        (side (if (cdr (assq :side params))
                (intern (concat ":" (cdr (assq :side params))))
                :instance))
        (code (encode-coding-string body 'latin-1)))
    (case type
      (:code (literate-smalltalk-eval code))
      (:method
          (literate-smalltalk-compile-method
           (cdr (assq :ns params))
           (cdr (assq :class params))
           side
           (cdr (assq :cat params))
           code))
      (:class
       (literate-smalltalk-compile-class code))
      (t
       (error "Unknown type %s" type)))))
#+END_SRC

** code format
#+BEGIN_SRC elisp
(defun literate-smalltalk-code-format-current-code-block ()
  (interactive)
  (let* ((block-info (second (org-element-context)))
         (code (plist-get block-info :value))
         (formatted-code (literate-smalltalk-format-code code)))
    (replace-region-contents
     (plist-get block-info :begin)
     (plist-get block-info :end)
     (lambda ()
       (let* ((beg-src-line (progn (goto-char (point-min))
                                   (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))))
         (concat beg-src-line "\n"
                 formatted-code "\n"
                 "#+END_SRC\n"))))))
#+END_SRC

** shortcut
#+BEGIN_SRC elisp
(define-quick-choice (literate-smalltalk-code-mode)
    ("package of class" literate-smalltalk-namespace-of-current-symbol)
  ("compile codes" org-babel-execute-src-block-maybe)
  ("format code" literate-smalltalk-code-format-current-code-block)
  ("update codes" literate-smalltalk-update-source)
  )
#+END_SRC

** Test
*** eval codes
:PROPERTIES:
:results:  value
:END:
#+BEGIN_SRC st :type code :results raw
y := Dictionary new.
y at: 'page' put: '2'.
(IsInteger matchesTo: (y at: 'page'))
   ifTrue: [ (y at: 'page') IsInteger parseString (y at: 'page')]
   ifFalse: 1.
#+END_SRC
* Pharo side
:PROPERTIES:
:literate-ns:    LiterateSmalltalk
:END:
** baseline
*** definition
#+BEGIN_SRC st :type class :name BaselineOfLiterateSmalltalk :ns BaselineOfLiterateSmalltalk
BaselineOf subclass: #BaselineOfLiterateServer
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'BaselineOfLiterateSmalltalk'
----------------------
BaselineOfLiterateServer class
    instanceVariableNames: ''
#+END_SRC
*** spec
#+BEGIN_SRC st :type method :class BaselineOfLiterateServer :side instance :cat "baselines"
baselineOf: spec

	<baseline>
	spec for: #common do: [
		self setUpDependencies: spec.
		spec
			package: 'LiterateSmalltalk'
			with: [ spec requires: #( 'Teapot' ) ].
		spec group: 'default' with: #( 'LiterateSmalltalk' ) ]
#+END_SRC
** a Teapot server to handle request
:PROPERTIES:
:literate-lang: st
:literate-namespace:    LiterateSmalltalk
:literate-class:    LiterateServer
:END:
*** definition
#+BEGIN_SRC st :type class :name LiterateServer :ns LiterateSmalltalk
Object subclass: #LiterateServer
    instanceVariableNames: ''
    classVariableNames: 'Server Started'
    package: 'LiterateSmalltalk'
----------------------
LiterateServer class
    instanceVariableNames: ''
#+END_SRC
*** the Server accessor
**** reader
#+BEGIN_SRC st :type method :name server :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
server
	"returns teapot instance"
	^ Server
#+END_SRC
**** writer
#+BEGIN_SRC st :type method :name server: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
server: server
	"sets teapot for class"
	Server := server.
#+END_SRC
*** start the routes
#+BEGIN_SRC st :type method :name start :class LiterateServer :side class :cat "management" :ns LiterateSmalltalk
start

	"Start the webserver"

	| teapot |
	"extra check so that we don't close a Pool which wasn't open"
	Started ifNotNil: [ Server stop ].
	teapot := Teapot configure: {
			          (#defaultOutput -> #json).
			          (#port -> 9092).
			          (#debugMode -> true).
			          (#bindAddress -> #[ 127 0 0 1 ]) }.
	self server: teapot.
	teapot
		GET: '/namespaces' -> [ :req | self namespaces ];
		GET: '/classes/<namespace>'
			-> [ :req | self classes: (req at: #namespace) ];
		GET: '/class/<class>' -> [ :req | self classDef: (req at: #class) ];
		GET: '/cats/<class>' -> [ :req | self classCats: (req at: #class) ];
		GET: '/cat/methods' -> [ :req |
				self
					catMethods: (req at: #class)
					category: (req at: #cat)
					side: (req at: #side) ];
		GET: '/method/source' -> [ :req |
				self
					methodSource: (req at: #class)
					name: (req at: #name)
					side: (req at: #side) ];
		POST: '/eval' -> [ :req | self evalCode: (req at: #code) ];
		POST: '/compile/class' -> [ :req |
				self
					compileClass: (NeoJSONReader fromString: (req at: #instance))
					class: (NeoJSONReader fromString: (req at: #class)) ];
		POST: '/compile/method' -> [ :req |
				self
					compileMethod: (req at: #class)
					category: (req at: #category)
					source: (req at: #source)
					side: (req at: #side) ];
		POST:
			'/format/code' -> [ :req | self formatCode: (req at: #source) ];
		exception:
			KeyNotFound -> (TeaResponse notFound body: 'No such method');
		start.

	Started := true
#+END_SRC
*** asStringArray:
Many reflection methods return different results in various dialects.
=#instVarNames= in GNU Smalltalk returns an IdentitySet of Symbols, the
same method returns an Array of Strings in Squeak

This kludge works as an abstraction over it all
#+BEGIN_SRC st :type method :class LiterateServer :side class :cat "utilities" :ns LiterateSmalltalk
asStringArray: items

	^ (items collect: [ :each | each asString ]) asArray
#+END_SRC
*** elementsString
#+BEGIN_SRC st :type method :class LiterateServer :side class :cat "utilities" :ns LiterateSmalltalk
elementsString: str

	^ String join: str separatedBy: ' '
#+END_SRC
*** get namespaces
#+BEGIN_SRC st :type method :name namespaces :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
namespaces

	| names |
	names := (Smalltalk allClasses collect: [ :each |
		          each category asString ]) asSet asSortedCollection.
	^ { (#namespaces -> names) } asDictionary
#+END_SRC
*** get classes of one namespace
#+BEGIN_SRC st :type method :name classes :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
classes: namespace

	| resultList |
	resultList := Smalltalk allClasses select: [ :each |
		              each category asString = namespace ].
	^ { (#classes -> (resultList collect: [ :each | each name asString ])) }
		  asDictionary
#+END_SRC
*** get class information
#+BEGIN_SRC st :type method :name classDef: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
classDef: className

	| class instanceSide classSide result |
	class := Smalltalk at: className asSymbol.
	instanceSide := Dictionary new.
	instanceSide at: #class put: className.
	instanceSide at: #superclass put: class superclass printString.
	instanceSide
		at: #instvars
		put: (self asStringArray: class instVarNames).
	instanceSide
		at: #classvars
		put: (self asStringArray: class classVarNames).
	instanceSide
		at: #poolvars
		put: (self asStringArray: class sharedPools).
	instanceSide at: #package put: class category.

	class := class class.
	classSide := Dictionary new.
	classSide at: #class put: className.
	classSide at: #superclass put: class superclass printString.
	classSide at: #instvars put: (self asStringArray: class instVarNames).
	classSide
		at: #classvars
		put: (self asStringArray: class classVarNames).
	classSide at: #poolvars put: (self asStringArray: class sharedPools).
	result := Dictionary new.
	result at: #instance put: instanceSide.
	result at: #class put: classSide.
	^ result
#+END_SRC
*** get class categories
#+BEGIN_SRC st :type method :name classCats: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
classCats: className

	| class cats instanceSide classSide |
	result := Dictionary new.
	class := Smalltalk at: className asSymbol.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d |
		d values do: [ :each | cats add: each category ] ].

	result at: #instance put: cats.

	class := class class.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d |
		d values do: [ :each | cats add: each category ] ].
	result at: #class put: cats.
	^ result
#+END_SRC
*** get methods in one class category
#+BEGIN_SRC st :type method :name catMethods: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
catMethods: className category: cat side: side

	| class methods allMethods result |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	allMethods := class methodDictionary
		              ifNil: [ #(  ) ]
		              ifNotNil: [ :x | x associations ].

	methods := cat = '*'
		           ifTrue: [ allMethods ]
		           ifFalse: [
		           allMethods select: [ :e | e value category = cat ] ].
	^ { (#methods
	   ->
	   (methods collect: [ :each | each key asString ])
		   asSortedCollection) } asDictionary
#+END_SRC
*** get method source
#+BEGIN_SRC st :type method :name methodSource: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
methodSource: className name: name side: side

	| class method |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].
	method := class methodDictionary at: name asSymbol.
	^ { (#source -> method sourceCode) } asDictionary
#+END_SRC
*** eval code
#+BEGIN_SRC st :type method :name methodSource: :class LiterateServer :side class :cat "compile" :ns LiterateSmalltalk
evalCode: code

	| status result |
	status := #success.
	result := [
	          OpalCompiler new
		          source: code;
		          evaluate ] onErrorDo: [ result := #failed ].
	^ {
		  (#result -> result).
		  (#status -> status) } asDictionary
#+END_SRC
*** compile class
#+BEGIN_SRC st :type method :name compileMethod :class LiterateServer :side class :cat "compile" :ns LiterateSmalltalk
compileClass: instDef class: classDef

	| parent class status instvars classvars |
	status := #success.
	instvars := ''.
	(instDef at: #instvars) ifNotNil: [
		instvars := self elementsString: (instDef at: #instvars) ].

	classvars := ''.
	(instDef at: #classvars) ifNotNil: [
		classvars := self elementsString: (instDef at: #classvars) ].

	"Looks a bit kludgy, but currently I dont know how to make it better. TODO: refactor"
	parent := Smalltalk at: (instDef at: #super) asSymbol.
	[
	class := parent
		         subclass: (instDef at: #name) asSymbol
		         instanceVariableNames: instvars
		         classVariableNames: classvars
		         poolDictionaries: ''
		         category: (instDef at: #package) ]
		on: Error
		do: [ :e |
			Transcript
				show: e printString;
				cr.
			status := #failed ].

	class := Smalltalk at: (instDef at: #name) asSymbol ifAbsent: [ nil ].
	"On Pharo, there were a strange exception when using the safe form."
	instvars := ''.
	(classDef at: #instvars) ifNotNil: [
		instvars := self elementsString: (classDef at: #instvars) ].
	class class instanceVariableNames: instvars.

	^ { (#status -> status) } asDictionary
#+END_SRC
*** compile method
#+BEGIN_SRC st :type method :name compileMethod :class LiterateServer :side class :cat "compile" :ns LiterateSmalltalk
compileMethod: className category: cat source: source side: side

	| class result |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	result := #success.
	[ class compile: source classified: cat ] onErrorDo: [ result := #failed ].
	^ { (#result -> result) } asDictionary
#+END_SRC
*** format code
#+BEGIN_SRC st :type method :class LiterateServer :side class :cat "compile"
formatCode: source

	| tree |
	tree := RBParser
		        parseMethod: source
		        onError: [ :msg :pos |
		        ^ { (#status -> #failed) } asDictionary ].
	^ {
		  (#status -> #success).
		  (#source -> tree formattedCode) } asDictionary
#+END_SRC
