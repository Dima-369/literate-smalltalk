# -*- encoding:utf-8 Mode: POLY-ORG; tab-width: 2; org-src-preserve-indentation: t; -*- ---
#+TITLE: Literate programming tool to write Smalltalk in org mode.
#+SubTitle: inspired by shampoo.
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+LATEX_HEADER: % copied from lstlang1.sty, to add new language support to Emacs Lisp.
#+LATEX_HEADER: \lstdefinelanguage{elisp}[]{lisp} {}
#+LATEX_HEADER: \lstloadlanguages{elisp}
#+PROPERTY: header-args
#+PROPERTY: literate-load yes
#+PROPERTY: literate-class LiterateServer
* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#preparation][Preparation]]
- [[#how-to-do-it-68][How to do it?]]
- [[#a-minor-mode-for-source-code][a minor mode for source code]]
  - [[#font-lock-keywords][font lock keywords]]
    - [[#binary-selectors][binary selectors]]
    - [[#basic-font-lock-keywords][basic font lock keywords]]
    - [[#level-1-smalltalk-font-locking-keywords][Level 1 Smalltalk font-locking keywords]]
    - [[#level-2-smalltalk-font-locking-keywords][Level 2 Smalltalk font-locking keywords]]
    - [[#font-lock-keywords-list][font lock keywords list]]
  - [[#syntax-table][syntax table]]
  - [[#mode-definition][mode definition]]
  - [[#add-to-auto-mode-alist][add to auto mode alist]]
- [[#utilities][utilities]]
  - [[#select-helm-marked-candidates][select helm marked candidates]]
  - [[#forward-to-begin-of-function][forward to begin of function]]
  - [[#region-of-current-symbol][region of current symbol]]
  - [[#current-symbol-at-point][current symbol at point]]
  - [[#previous-symbol-at-point][previous symbol at point]]
  - [[#check-autogenerated-code][check autogenerated code]]
  - [[#get-selector-from-a-line-of-code][get selector from a line of code]]
  - [[#api-request][api request]]
- [[#baseline-for-pharo][baseline for pharo]]
  - [[#definition][definition]]
  - [[#spec][spec]]
- [[#a-teapot-server-to-handle-request][a Teapot server to handle request]]
  - [[#definition-1][definition]]
  - [[#the-server-accessor][the Server accessor]]
    - [[#reader][reader]]
    - [[#writer][writer]]
  - [[#routes][routes]]
  - [[#log-messages-in-transcript][log messages in Transcript]]
    - [[#emacs][Emacs]]
    - [[#pharo][Pharo]]
  - [[#utils][utils]]
    - [[#asstringarray][asStringArray:]]
    - [[#elementsstring][elementsString]]
    - [[#bringtofront][bringToFront]]
- [[#query][Query]]
  - [[#namespace][namespace]]
    - [[#namespaces][namespaces]]
    - [[#classes-for-one-namespace][classes for one namespace]]
  - [[#package][package]]
    - [[#a-list-of-all-packages][a list of all packages]]
    - [[#a-list-of-package-tags][a list of package tags.]]
    - [[#a-list-of-classes-for-a-package-tag][a list of classes for a package tag]]
    - [[#a-list-of-package-extensions][a list of package extensions.]]
  - [[#class][class]]
    - [[#emacs-1][Emacs]]
    - [[#pharo-1][Pharo]]
- [[#compile][Compile]]
  - [[#eval-code][eval code]]
    - [[#emacs-2][Emacs]]
    - [[#pharo-2][Pharo]]
  - [[#compile-1][compile]]
    - [[#emacs-3][Emacs]]
    - [[#command-to-code-format][command to code format]]
    - [[#command-to-delete-a-class-method][command to delete a class method]]
    - [[#code-completion-with-company-mode][code completion with company mode]]
    - [[#pharo-3][Pharo]]
- [[#code-navigation][Code navigation]]
  - [[#search-a-pattern-in-a-buffer-and-return-its-position][search a pattern in a buffer and return its position]]
  - [[#find-definition-of-class-in-org-files][find definition of class in org files]]
  - [[#find-definition-of-a-class-method-in-org-files][find definition of a class method in org files]]
  - [[#get-method-name-from-method-codes][get method name from method codes]]
  - [[#basic-idea][basic idea]]
  - [[#xref-interfaces][xref interfaces]]
  - [[#implementation][implementation]]
- [[#update-source][Update source]]
- [[#imports-codes-to-org-file][imports codes to org file]]
  - [[#import-codes-of-namespaces-to-org-mode][Import codes of namespaces to org mode]]
  - [[#import-codes-of-packages-to-org-mode][Import codes of packages to org mode]]
- [[#babel-support][babel support]]
  - [[#optionally-define-a-file-extension-for-this-language][optionally define a file extension for this language]]
  - [[#optionally-declare-default-header-arguments][optionally declare default header arguments]]
  - [[#source-code-execution][Source Code Execution]]
    - [[#babel-entry][babel entry]]
    - [[#implementation-1][implementation]]
  - [[#execute-all-source-codes-in-current-header][execute all source codes in current header]]
  - [[#execute-source-codes-in-current-code-block][execute source codes in current code block]]
- [[#release-to-pharo][Release to pharo]]
- [[#test][Test]]
  - [[#eval-codes][eval codes]]
  - [[#ban-some-critiques-rules][ban some critiques rules]]
  - [[#test-1][test]]

* Introduction
This is an attemp to write smalltalk codes in org mode,
and interact with remote [[https://pharo.org/][pharo]] images inspired from [[https://github.com/dmatveev/shampoo-emacs][shampoo]]([[https://github.com/jingtaozf/shampoo-pharo.git][shampo for pharo]]).
* Preparation
You need to install pharo side codes in pharo and start server by the following codes
#+begin_src st
LiterateServer start.
#+end_src
* How to do it? [6/8]

We setup a HTTP server in Pharo, so Emacs can interact with Pharo to
- fetch packages, classes, method source
- compile class/methods
- format code block
- show suggestions, etc.


- [X] Find packages's sub category
  https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Extensions.md#define-an-extension-method-programmatically
- [X] Find package's extensions
  (RPackageOrganizer default packageMatchingExtensionName: #packagename) metaclassExtensionSelectors .
- [X] Tonel read write
  https://gist.github.com/peteruhnak/e4ba8d52bf4a89c4c9e015bb59b442fd
- [X] opal compile
	https://gist.github.com/peteruhnak/e2235e43a25feb6cf0d7196192cf8aea
- [X] remove a class method at point
  MyClass removeFromSystem
  MyClass removeSelector: #foo
- [ ] raise pharo window when any exception
- [ ] rename class methods
	https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/CoolSnippets.md#rename-programatically-methods
- [X] playground/REPL in Emacs
  StPlaygroundInteractionModel
* a minor mode for source code
:PROPERTIES:
:literate-lang: elisp
:END:
inspired from shampoo-code-mode
** font lock keywords
*** binary selectors
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-binsel "\\([-+*/~,<>=&?]\\{1,2\\}\\|:=\\|||\\)"
"Smalltalk binary selectors")
#+END_SRC
*** basic font lock keywords
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords
(list
'("#[A-z][A-z0-9_]*"          . font-lock-constant-face)
'("\\<[A-z][A-z0-9_]*:"       . font-lock-function-name-face)
(cons literate-smalltalk-smalltalk-binsel 'font-lock-function-name-face)
'("\\$."                      . font-lock-string-face)
'("\\<[A-Z]\\sw*\\>"          . font-lock-type-face)
'("[0-9]+"                    . font-lock-constant-face))
"Basic Smalltalk keywords font-locking")
#+END_SRC
*** Level 1 Smalltalk font-locking keywords
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords-1
literate-smalltalk-smalltalk-font-lock-keywords
"Level 1 Smalltalk font-locking keywords")
#+END_SRC

*** Level 2 Smalltalk font-locking keywords
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords-2
(append literate-smalltalk-smalltalk-font-lock-keywords-1
(list
		'("\\<\\(true\\|false\\|nil\\|self\\|super\\)\\>"
		. font-lock-builtin-face)
		'(":[a-z][A-z0-9_]*" . font-lock-variable-name-face)
		'(" |"               . font-lock-type-face)
		'("<.*>"             . font-lock-builtin-face)))
"Level 2 Smalltalk font-locking keywords")
#+END_SRC
*** font lock keywords list
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-font-lock-keywords-list
'((literate-smalltalk-smalltalk-font-lock-keywords
		literate-smalltalk-smalltalk-font-lock-keywords-1
		literate-smalltalk-smalltalk-font-lock-keywords-2)))
#+END_SRC
** syntax table
#+BEGIN_SRC elisp
(defvar literate-smalltalk-smalltalk-mode-syntax-table
(let ((table (make-syntax-table)))
;; Make sure A-z0-9 are set to "w   " for completeness
(let ((c 0))
		(setq c ?0)
		(while (<= c ?9)
(setq c (1+ c))
(modify-syntax-entry c "w   " table))
		(setq c ?A)
		(while (<= c ?Z)
(setq c (1+ c))
(modify-syntax-entry c "w   " table))
		(setq c ?a)
		(while (<= c ?z)
(setq c (1+ c))
(modify-syntax-entry c "w   " table)))
(modify-syntax-entry 10  " >  " table) ; Comment (generic)
(modify-syntax-entry ?:  ".   " table) ; Symbol-char
(modify-syntax-entry ?_  "_   " table) ; Symbol-char
(modify-syntax-entry ?\" "!1  " table) ; Comment (generic)
(modify-syntax-entry ?'  "\"  " table) ; String
(modify-syntax-entry ?#  "'   " table) ; Symbol or Array constant
(modify-syntax-entry ?\( "()  " table) ; Grouping
(modify-syntax-entry ?\) ")(  " table) ; Grouping
(modify-syntax-entry ?\[ "(]  " table) ; Block-open
(modify-syntax-entry ?\] ")[  " table) ; Block-close
(modify-syntax-entry ?{  "(}  " table) ; Array-open
(modify-syntax-entry ?}  "){  " table) ; Array-close
(modify-syntax-entry ?$  "/   " table) ; Character literal
(modify-syntax-entry ?!  ".   " table) ; End message / Delimit defs
(modify-syntax-entry ?\; ".   " table) ; Cascade
(modify-syntax-entry ?|  ".   " table) ; Temporaries
(modify-syntax-entry ?^  ".   " table) ; Return
;; Just to make sure these are not set to "w   "
(modify-syntax-entry ?<  ".   " table)
(modify-syntax-entry ?>  ".   " table)
(modify-syntax-entry ?+  ".   " table) ; math
(modify-syntax-entry ?-  ".   " table) ; math
(modify-syntax-entry ?*  ".   " table) ; math
(modify-syntax-entry ?/  ".2  " table) ; math
(modify-syntax-entry ?=  ".   " table) ; bool/assign
(modify-syntax-entry ?%  ".   " table) ; valid selector
(modify-syntax-entry ?&  ".   " table) ; boolean
(modify-syntax-entry ?\\ ".   " table) ; ???
(modify-syntax-entry ?~  ".   " table) ; misc. selector
(modify-syntax-entry ?@  ".   " table) ; Point
(modify-syntax-entry ?,  ".   " table) ; concat
table)
"Syntax table used by Smalltalk mode")
#+END_SRC

** mode definition
#+BEGIN_SRC elisp
(define-derived-mode literate-smalltalk-code-mode
    text-mode "Literate Smalltalk code"
    (set (make-local-variable 'font-lock-defaults)
				 literate-smalltalk-smalltalk-font-lock-keywords-list)
    (set (make-local-variable 'comment-start) "\"")
    (set (make-local-variable 'comment-end) "\"")
    (set (make-local-variable 'case-fold-search) nil)
    (set-syntax-table literate-smalltalk-smalltalk-mode-syntax-table))
#+END_SRC
** add to auto mode alist
#+BEGIN_SRC elisp
(setq auto-mode-alist (append '(("\\.st\\'" . literate-smalltalk-code-mode)) auto-mode-alist))
#+END_SRC
* utilities
** select helm marked candidates
#+BEGIN_SRC elisp
(defun literate-smalltalk-helm-select-list (prompt list)
  (let* ((list (typecase list
                 (vector (mapcar 'identity list))
                 (t list)))
         (helm-selected-value nil)
         (helm-source
           `((name . ,prompt)
             (candidates . ,list)
             (action . (lambda (candidate)
                         (setf helm-selected-value
                                 (helm-marked-candidates)))))))
    (helm :sources '(helm-source) :prompt prompt)
    helm-selected-value))
#+END_SRC

** forward to begin of function
#+BEGIN_SRC elisp
(defun literate-smalltalk-beginning-of-defun-function (arg)
  (if (> arg 0)
    (progn
      (search-backward "#+BEGIN_SRC ")
      (forward-line))
    (literate-smalltalk-end-of-defun-function)))

(defun literate-smalltalk-end-of-defun-function (arg)
  (search-forward "#+END_SRC")
  (forward-line -1))

(defun install-literate-smalltalk-beginning-of-defun-function ()
  (make-local-variable 'beginning-of-defun-function)
  (make-local-variable 'end-of-defun-function)
  (setf beginning-of-defun-function 'literate-smalltalk-beginning-of-defun-function)
  (setf end-of-defun-function 'literate-smalltalk-end-of-defun-function)
  )
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-beginning-of-defun-function)
#+END_SRC
** region of current symbol
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-region ()
  (save-excursion
    (let* ((beg (re-search-backward "[ \t\n\r(^[]" nil t))
           (end (progn
                  (forward-char)
                  (re-search-forward "[ \t\n\r\.]" nil t)
                  (backward-char)
                  (point))))
      (cons beg end))))
#+END_SRC

** current symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-at-point ()
  (let* ((region (literate-smalltalk-current-symbol-region))
         (beg (car region))
         (end (cdr region)))
    (string-trim (buffer-substring-no-properties beg end) "[ \t\n\r(^]+")))
#+END_SRC
** previous symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-previous-symbol-at-point ()
  (save-excursion
    (re-search-backward "[ \t\n\r]" nil t)
    (forward-word -1)
    (literate-smalltalk-current-symbol-at-point)))
#+END_SRC
** check autogenerated code
#+BEGIN_SRC elisp
(defvar literate-smalltalk-autogenerated-code-patterns nil)
(defun literate-smalltalk-autogenerated-code? (code)
  (loop for pattern in literate-smalltalk-autogenerated-code-patterns
        thereis (funcall pattern code)))
#+END_SRC
** get selector from a line of code
#+BEGIN_SRC elisp
(defun literate-smalltalk-extract-selector (line)
  (let ((parts (split-string line)))
    (if (= 1 (length parts))
      (car parts)
      (apply 'concat (loop for part in parts
                          if (search ":" part)
                            collect part)))))
#+END_SRC

** api request
#+BEGIN_SRC elisp
(defvar literate-smalltalk-rest-server "http://localhost:9092/")
(defvar literate-smalltalk-last-response nil)
(cl-defun literate-smalltalk-request (path &key params data (type "GET"))
  (let ((resp nil))
    (request (concat literate-smalltalk-rest-server path)
        :params params
        :parser 'json-read
        :type type
        :sync t
        :data data
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-smalltalk-last-response response)
                     (case (request-response-status-code response)
                       (200 (setf resp (request-response-data response)))
                       (500 (error "Pharo failed:%s" (cdr (assoc 'message resp))))
                       (t (error "Failed to request to remote pharo:%s" response))))))
    resp))
#+END_SRC
* baseline for pharo
:PROPERTIES:
:literate-class: BaselineOfLiterateSmalltalk
:END:
** definition
#+BEGIN_SRC smalltalk
"
Baseline of LiterateSmalltalk.
"
BaselineOf subclass: #BaselineOfLiterateSmalltalk
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'BaselineOfLiterateSmalltalk'
----------------------
BaselineOfLiterateSmalltalk class
    instanceVariableNames: ''
#+END_SRC
** spec
#+BEGIN_SRC smalltalk :cat "baseline" :side instance
baselineOf: spec

	<baseline>
	spec for: #common do: [
		spec
			baseline: 'Teapot' with: [
				spec
					repository: 'github://zeroflag/Teapot:v2.6.0/source';
					loads: #( 'Deployment' ) ];
			import: 'Teapot'.
		spec
			package: 'LiterateSmalltalk'
			with: [ spec requires: #( 'Teapot' ) ].
		spec group: 'default' with: #( 'LiterateSmalltalk' ) ]
#+END_SRC
* a Teapot server to handle request
** definition
#+BEGIN_SRC smalltalk
"
The REST Server for LiterateSmalltalk.
"
Object subclass: #LiterateServer
    instanceVariableNames: ''
    classVariableNames: 'Server Started interactionModel transcriptLogStream'
    package: 'LiterateSmalltalk'
----------------------
LiterateServer class
    instanceVariableNames: ''
#+END_SRC
** the Server accessor
*** reader
#+BEGIN_SRC smalltalk :side class :cat "accessing"
server
	"returns teapot instance"
	^ Server
#+END_SRC
*** writer
#+BEGIN_SRC smalltalk :side class :cat "accessing"
server: server
	"sets teapot for class"
	Server := server.
#+END_SRC
** routes
#+BEGIN_SRC smalltalk :side class :cat "management"
start

	"Start the webserver"

	| teapot |
	"extra check so that we don't close a Pool which wasn't open"
	Started ifNotNil: [ Server stop ].
	Transcript removeDependent: self.
	Transcript addDependent: self.
	teapot := Teapot configure: {
			          (#defaultOutput -> #json).
			          (#port -> 9092).
			          (#debugMode -> true).
			          (#bindAddress -> #[ 127 0 0 1 ]) }.
	teapot server logLevel: 1.
	self server: teapot.
	teapot
		GET: '/namespaces' -> [ :req | self namespaces ];
		GET: '/classes/<namespace>' -> [ :req | self classes: (req at: #namespace) ];
		GET: '/packages' -> [ :req | self packages ];
		GET: '/package/tags/<package>' -> [ :req | self packageTags: (req at: #package) ];
		GET:
			'/package/extensions/<package>'
			-> [ :req | self packageExtensions: (req at: #package) ];
		GET: '/class/<class>' -> [ :req | self classDef: (req at: #class) ];
		GET: '/cats/<class>' -> [ :req | self classCats: (req at: #class) ];
		GET: '/cat/methods'
			-> [ :req |
				self catMethods: (req at: #class) category: (req at: #cat) side: (req at: #side) ];
		GET: '/method/source'
			-> [ :req |
				self methodSource: (req at: #class) name: (req at: #name) side: (req at: #side) ];
		GET: '/method/remove' -> [ :req |
				self removeSelector: (req at: #class) name: (req at: #name) side: (req at: #side) ];
		POST: '/eval'
			-> [ :req | self evalCode: (req at: #code) openInspector: (req at: #inspector) = #true ];
		GET: '/eval/bindings' -> [ :req | self evalBindings ];
		GET: '/remove/class' -> [ :req | self removeClass: (req at: #class) ];
		POST: '/compile/class' -> [ :req |
				self
					compileClass: (NeoJSONReader fromString: (req at: #instance))
					class: (NeoJSONReader fromString: (req at: #class)) ];
		POST: '/compile/method' -> [ :req |
				self
					compileMethod: (req at: #class)
					category: (req at: #category)
					source: (req at: #source)
					side: (req at: #side) ];
		POST:
			'/format/code' -> [ :req | self formatCode: (req at: #source) type: (req at: #type) ];
		POST: '/completion/method'
			-> [ :req | self completion: (req at: #class) source: (req at: #source) ];
		exception: Exception -> [ :ex :req |
				self bringToFront.
				ex pass.
				ZnResponse serverError: (NeoJSONWriter toString: {
									 (#status -> #fatal).
									 (#message -> ex asString) } asDictionary) ];
		start.
	interactionModel := StPlaygroundInteractionModel new owner: StPlaygroundPagePresenter new.
	Started := true
#+END_SRC
** log messages in Transcript
We will just output it to a log file, and can monitor them in a Emacs buffer.
*** Emacs
#+BEGIN_SRC elisp
(defvar literate-smalltalk-transcript-log-file "~/.cache/literate-smalltalk/transcript.log")
(make-directory (file-name-directory literate-smalltalk-transcript-log-file) t)
#+END_SRC

*** Pharo
An interface to update of Transcript.
#+BEGIN_SRC smalltalk :side class :cat updating
update: aChange

	aChange = #appendEntry ifFalse: [ ^ self ].
	transcriptLogStream ifNotNil: [
		transcriptLogStream closed ifTrue: [ transcriptLogStream := nil ] ].
	transcriptLogStream ifNil: [
		transcriptLogStream := ((OSEnvironment current at: 'HOME')
		                        , '/.cache/literate-smalltalk/transcript.log') asFileReference
			                       writeStream.
		transcriptLogStream setToEnd ].
	transcriptLogStream print: Transcript contents.
	transcriptLogStream flush
#+END_SRC
** utils
*** asStringArray:
Many reflection methods return different results in various dialects.
=#instVarNames= in GNU Smalltalk returns an IdentitySet of Symbols, the
same method returns an Array of Strings in Squeak

This kludge works as an abstraction over it all
#+BEGIN_SRC smalltalk :side class :cat "utilities"
asStringArray: items

	^ (items collect: [ :each | each asString ]) asArray
#+END_SRC
*** elementsString
#+BEGIN_SRC smalltalk :side class :cat "utilities"
elementsString: items

	^ items inject: '' into: [ :acc :each | acc , each asString , ' ' ]
#+END_SRC
*** bringToFront
#+BEGIN_SRC smalltalk :side class :cat "utilities"
bringToFront

	"a way to bring pharo window to front"

	Display toggleFullscreen.
	Display toggleFullscreen.
#+END_SRC
* Query
** namespace
*** namespaces
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespaces ()
  (cdr (assoc 'namespaces (literate-smalltalk-request "namespaces"))))

(defun literate-smalltalk-select-namespace ()
  (literate-smalltalk-helm-select-list "namespace" (literate-smalltalk-namespaces)))
#+END_SRC
**** pharo
#+BEGIN_SRC smalltalk :side class :cat "accessing"
namespaces

	| names |
	names := (Smalltalk globals allClasses collect: [ :each |
		          each category asString ]) asSet asSortedCollection.
	^ { (#status -> #success). (#namespaces -> names) } asDictionary
#+END_SRC
**** cache relationship between namespace and class
It is slow to build such indexed from remote pharo, let store it to a global variable and cache it to local file.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-indexed-classes-file "~/.emacs.d/smalltalk.classes.txt")
(defvar literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
(defun literate-smalltalk-index-classes ()
  (interactive)
  (loop for namespace in (literate-smalltalk-namespaces)
        do (message "Indexing %s" namespace)
           (loop for class in (literate-smalltalk-classes namespace)
                 do (setf (gethash class literate-smalltalk-indexed-classes) namespace)))
  (with-current-buffer (find-file-noselect literate-smalltalk-indexed-classes-file)
    (erase-buffer)
    (fundamental-mode)
    (maphash (lambda (k v)
               (insert k " " v "\n"))
             literate-smalltalk-indexed-classes)
    (save-buffer)
    (kill-current-buffer)))

(defun literate-smalltalk-restore-indexed-classes ()
  (interactive)
  (message "start restoring...")
  (setf literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
  (cl-loop for line in (s-split "\n" (f-read literate-smalltalk-indexed-classes-file) t)
           for items = (s-split " " line)
           do (setf (gethash (car items) literate-smalltalk-indexed-classes) (second items)))
  (message "restoring...done"))
#+END_SRC
**** get namespace of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-of-a-class (class)
  (when (= 0 (hash-table-count literate-smalltalk-indexed-classes))
    (error "Please build the cache before use namespace of a class."))
  (gethash class literate-smalltalk-indexed-classes))

(defun literate-smalltalk-namespace-of-current-symbol ()
  (interactive)
  (let ((class (thing-at-point 'symbol)))
    (message "%s's namespace is %s" class (literate-smalltalk-namespace-of-a-class class))))
#+END_SRC


*** classes for one namespace
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-classes (namespace)
  (mapcar 'identity
          (cdr (assoc 'classes (literate-smalltalk-request (concat "classes/" namespace))))))

(defun literate-smalltalk-select-a-class (namespace)
  (literate-smalltalk-helm-select-list "Please select a namespace: " (literate-smalltalk-classes namespace)))
#+END_SRC
**** Pharo
#+BEGIN_SRC smalltalk :side class :cat "accessing"
classes: namespace

	| resultList |
	resultList := Smalltalk globals allClasses select: [ :each |
		              each category asString = namespace ].
	^ {
		  (#status -> #success).
		  #classes -> (resultList collect: [ :each | each name asString ])  } asDictionary
#+END_SRC
** package
This bases on [[https://github.com/pharo-project/pharo/blob/Pharo9.0/src/RPackage-Core/RPackage.class.st][RPakcage]].
*** a list of all packages
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-packages ()
  (cdr (assoc 'packages (literate-smalltalk-request "packages"))))

(defun literate-smalltalk-select-package ()
  (literate-smalltalk-helm-select-list "Please select a package: " (literate-smalltalk-packages)))
#+END_SRC
**** pharo
#+BEGIN_SRC smalltalk :side class :cat "accessing"
packages

	^ {
		  (#status -> #success).
		  (#packages -> RPackageOrganizer default packageNames) } asDictionary
#+END_SRC
*** a list of package tags.
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-package-tags (package)
  (cdr (assoc 'tags (literate-smalltalk-request (concat "package/tags/" package)))))

(defun literate-smalltalk-select-package-tag (package)
  (literate-smalltalk-helm-select-list "Please select a package tag: " (literate-smalltalk-package-tags package)))
#+END_SRC
**** pharo
#+BEGIN_SRC smalltalk :side class :cat "accessing"
packageTags: packageName

	| package tags |
	package := RPackageOrganizer default
		           packageNamed: packageName asSymbol
		           ifAbsent: RPackage new.
	tags := (package classTags collect: [ :tag |
		         {
			         (#name -> tag name asString).
			         (#classes -> (tag orderedClasses collect: [ :each | each asString ])) }
			         asDictionary ]) sorted: [ :item | item at: #name ] ascending.
	^ {
		  (#status -> #success).
		  (#tags -> tags) } asDictionary
#+END_SRC
*** a list of classes for a package tag
*** a list of package extensions.
**** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-package-extensions (package)
  (cdr (assoc 'methods (literate-smalltalk-request (concat "package/extensions/" package)))))

(defun literate-smalltalk-select-package-extension (package)
  (literate-smalltalk-helm-select-list "Please select a package extension: " (literate-smalltalk-package-extensions package)))
#+END_SRC

**** pharo
#+BEGIN_SRC smalltalk :side class :cat "accessing"
packageExtensions: packageName

	| package methods |
	package := RPackageOrganizer default
		           packageNamed: packageName asSymbol
		           ifAbsent: RPackage new.
	methods := package extensionMethods collect: [ :each |
		           | class side |
		           class := each methodClass.
		           side := #instance.
		           (class isKindOf: Metaclass) ifTrue: [
			           side := #class.
			           class := class instanceSide ].
		           {
			           (#name -> each name).
			           (#selector -> each selector).
			           (#category -> each category).
			           (#side -> side).
			           (#code -> each sourceCode).
			           (#class -> class asString) } asDictionary ].
	^ {
		  (#status -> #success).
		  (#methods -> methods) } asDictionary
#+END_SRC
** class
*** Emacs
**** print out class definition
#+BEGIN_SRC elisp
(defconst literate-smalltalk-class-template
  '(("instanceVariableNames:" . instvars)
    ("classVariableNames:"    . classvars)
    ;; ("poolDictionaries:"      . poolvars)
    ))

(defconst literate-smalltalk-class-side-template
  '(("instanceVariableNames:" . instvars)))
(defvar literate-smalltalk-separator "----------------------")

(defun literate-smalltalk-class-definition-string (resp)
  (let ((instance (cdr (assoc 'instance resp)))
        (class (cdr (assoc 'class resp))))
    (with-temp-buffer
      (insert "\"")
      (newline)
      (insert (decode-coding-string (cdr (assoc 'comment instance)) 'latin-1-mac))
      (newline)
      (insert "\"")
      (newline)
      (insert
       (format "%s subclass: #%s"
               (cdr (assoc 'superclass instance))
               (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (insert (format
               "    package: '%s'"
               (cdr (assoc 'package instance))))
      (newline)
      (insert literate-smalltalk-separator)
      (newline)

      (insert (format "%s class" (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-side-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (trim-string (buffer-string)))))
#+END_SRC
**** get class definition
#+BEGIN_SRC elisp
(defun literate-smalltalk-class (class)
  (literate-smalltalk-class-definition-string (cdr (assoc 'result (literate-smalltalk-request (concat "class/" class))))))
#+END_SRC
**** get categories of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-categories (class)
  (cdr (assoc 'result (literate-smalltalk-request (concat "cats/" class)))))

;; (defun literate-smalltalk-select-a-category (namespace class)
;;   (literate-smalltalk-helm-select-list "Please select a namespace: " (literate-smalltalk-categories namespace class)))
#+END_SRC
**** get methods of one category
#+BEGIN_SRC elisp
(defun literate-smalltalk-category-methods (class category side)
  (mapcar 'identity
          (cdr (assoc 'methods (literate-smalltalk-request "cat/methods"
                                                           :params `(("class" . ,class)
                                                                     ("cat" . ,category)
                                                                     ("side" . ,side)))))))
#+END_SRC
**** get method source
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-source (class method side)
  (unless class
    (error "Please specifiy the class of current method!"))
  (unless side
    (error "Please specifiy the side of current method!"))
  (let* ((resp (literate-smalltalk-request
                "method/source"
                :params `(("class" . ,class)
                          ("name" . ,method)
                          ("side" . ,side))))
         (source (cdr (assoc 'source resp))))
    (decode-coding-string source 'latin-1-mac)))
#+END_SRC
*** Pharo
**** class definition
#+BEGIN_SRC smalltalk :side class :cat "accessing"
classDef: className

	| class instanceSide classSide result |
	class := Smalltalk at: className asSymbol.
	instanceSide := Dictionary new.
	instanceSide at: #class put: className.
	instanceSide at: #superclass put: class superclass printString.
	instanceSide
		at: #instvars
		put: (self asStringArray: class instVarNames).
	instanceSide
		at: #classvars
		put: (self asStringArray: class classVarNames).
	instanceSide
		at: #poolvars
		put: (self asStringArray: class sharedPools).
	instanceSide at: #package put: class category.
	instanceSide at: #comment put: class comment.

	class := class class.
	classSide := Dictionary new.
	classSide at: #class put: className.
	classSide at: #superclass put: class superclass printString.
	classSide at: #instvars put: (self asStringArray: class instVarNames).
	classSide
		at: #classvars
		put: (self asStringArray: class classVarNames).
	classSide at: #poolvars put: (self asStringArray: class sharedPools).
	result := Dictionary new.
	result at: #instance put: instanceSide.
	result at: #class put: classSide.
	^ {
		  (#status -> #success).
		  (#result -> result) } asDictionary
#+END_SRC
**** get class categories
#+BEGIN_SRC smalltalk :side class :cat "accessing"
classCats: className

	| class cats result |
	result := Dictionary new.
	class := Smalltalk at: className asSymbol.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d | d valuesDo: [ :each | cats add: each category ] ].

	result at: #instance put: cats.

	class := class class.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d | d valuesDo: [ :each | cats add: each category ] ].
	result at: #class put: cats.
	^ {
		  (#status -> #success).
		  (#result -> result) } asDictionary
#+END_SRC
**** get methods in one class category
#+BEGIN_SRC smalltalk :side class :cat "accessing"
catMethods: className category: cat side: side

	| class methods allMethods |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	allMethods := class methodDictionary ifNil: [ #(  ) ] ifNotNil: [ :x | x associations ].

	methods := cat = '*'
		           ifTrue: [ allMethods ]
		           ifFalse: [ allMethods select: [ :e | e value category = cat ] ].
	^ {
		  (#status -> #success).
		  (#methods -> (methods collect: [ :each | each key asString ]) asSortedCollection) }
		  asDictionary
#+END_SRC
*
**** get method source
#+BEGIN_SRC smalltalk :side class :cat "accessing"
methodSource: className name: methodName side: side

	| class method |
	class := Smalltalk at: className asSymbol.
	class := side = #class
		         ifTrue: [ class class ]
		         ifFalse: [ class ].
	method := class methodDictionary at: methodName asSymbol.
	^ {
		  (#status -> #success).
		  (#source -> method sourceCode) } asDictionary
#+END_SRC
* Compile
** eval code
*** Emacs
**** eval
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval (code inspector-p)
  (let ((resp (literate-smalltalk-request
               "eval"
               :type "POST"
               :data `(("code" . ,code)
                       ("inspector" . ,(if inspector-p
                                         "true"
                                         "false"))))))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'message resp))
      (error "Failed to eval code:'%s'!" (cdr (assoc 'message resp))))))
#+END_SRC
**** local bindings
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval-bindings ()
  (interactive)
  (let ((resp (literate-smalltalk-request "eval/bindings")))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'message resp))
      (error "Failed to list bindings:'%s'!" (cdr (assoc 'message resp))))))
#+END_SRC

*** Pharo
**** eval a code text
#+BEGIN_SRC smalltalk :side class :cat "compile"
evalCode: code openInspector: openInspector

	| status result receiver evaluationContext |
	status := #success.
	receiver := interactionModel doItReceiver.
	evaluationContext := interactionModel doItContext.
	result := receiver class compiler
		          source: code;
		          context: evaluationContext;
		          receiver: receiver;
		          requestor: nil; "As it is a remote request, we allow compiler handle messages such as exceptions"
		          failBlock: [ ^ nil ];
		          evaluate.

	openInspector ifTrue: [
		self bringToFront.
		GTInspector inspect: result ].
	^ {
		  (#message -> result asString).
		  (#status -> status) } asDictionary
#+END_SRC
**** list bindings of all evaluated codes.
#+BEGIN_SRC smalltalk :side class :cat "compile"
evalBindings

	self bringToFront.
	GTInspector inspect: interactionModel bindings.
	^ {
		  (#status -> #success).
		  (#message -> 'Inspector has been opened.') } asDictionary
#+END_SRC
** compile
*** Emacs
**** parse a regex
#+BEGIN_SRC elisp
(defvar literate-smalltalk-regexp-tokens
    '((:Wd "\\([A-z]+[0-9]*\\)")
      (:Ws "\\([A-z 0-9]*\\)")
      (:Wa "\\([A-z\\.0-9]*\\)")
      (:Wc "\\([A-z\-0-9]*\\)")
      (:D  "\\([0-9]*\\)")
      (:sp "[ \s\t\n\r]*")
      (:cr "\r")
      (:lf "\n")))

(defun literate-smalltalk-regexp-is-capture-token (sym)
  (let ((pattern (assoc sym literate-smalltalk-regexp-tokens)))
    (and (symbolp sym)
         pattern
         (string-match "^\\\\\(.*\\\\\)$" (cadr pattern)))))

(defun literate-smalltalk-regexp-parse (str pattern)
  (let ((regexp (reduce 'concat
                        (loop for each in pattern collect
                                                  (let ((re (assoc each literate-smalltalk-regexp-tokens)))
                                                    (if re (cadr re) each)))))
        (re-len (loop for each in pattern
                      sum (if (literate-smalltalk-regexp-is-capture-token each) 1 0))))
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (when (re-search-forward regexp nil t)
        (loop for i from 1 to re-len collect
              (match-string i))))))

(defun literate-smalltalk-regexp-parse-and-bind (str pattern bindings binder)
  (let ((parsed (literate-smalltalk-regexp-parse str pattern)))
    (when parsed
      (loop for binding in bindings for j from 0 do
        (funcall
          binder
          binding
          (nth j parsed)))
      t)))
#+END_SRC

**** how to parse a class message
#+BEGIN_SRC elisp
(cl-defun literate-smalltalk-parse-message (&key code pattern bindings to-split)
  (lexical-let ((data '()))
    (let* ((binder #'(lambda (key value)
                       (push (cons key value) data)))
           (%split-string #'(lambda (string)
                              (if (null string)
                                '()
                                (remove-if (lambda (x) (equal x "")) (split-string string "\s"))))))
      (if (literate-smalltalk-regexp-parse-and-bind code pattern bindings binder)
        (progn
          (dolist (k to-split)
            (let ((string (cdr (assoc k data))))
              (setf (cdr (assoc k data))
                      (if (null string) '()
                        (remove-if (lambda (x) (equal x "")) (funcall %split-string string))))))
          data)
        (progn (message "literate smalltalk: syntax error")
               nil)))))
#+END_SRC
**** parse class definition
#+BEGIN_SRC elisp
(defvar literate-smalltalk-class-side-pattern
    '(:Wd :sp "class" :sp "instanceVariableNames:" :sp "'" :Ws "'"))
(defun literate-smalltalk-parse-class-definition (code)
  (literate-smalltalk-parse-message
   :code code
   :pattern literate-smalltalk-class-side-pattern
   :bindings '(:name :instvars)
   :to-split '(:instvars)))
#+END_SRC

**** parse subclass definition
#+BEGIN_SRC elisp
(defvar literate-smalltalk-subclass-pattern
    '(:Wa :sp "subclass:" :sp "#" :Wd
      :sp "instanceVariableNames:" :sp "'" :Ws "'"
      :sp "classVariableNames:"    :sp "'" :Ws "'"
      ;; :sp "poolDictionaries:"      :sp "'" :Ws "'"
      :sp "package:"              :sp "'" :Wc "'"
      ))
(defun literate-smalltalk-parse-subclass-definition (code)
  (literate-smalltalk-parse-message
   :code code
   :pattern literate-smalltalk-subclass-pattern
   :bindings '(:super :name :instvars :classvars :package)
   :to-split '(:instvars :classvars)))
#+END_SRC

**** compile class
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-class (code)
  (let (comment instance-code class-code anchor-pos)
    (with-temp-buffer
      (insert code)
      (goto-char (point-min))
      (search-forward-regexp "^\"$")
      (setf anchor-pos (point))
      (search-forward-regexp "^\"$")
      (forward-line -1)
      (setf comment (buffer-substring-no-properties anchor-pos (line-end-position)))
      (forward-line 2)
      (setf anchor-pos (line-beginning-position))
      (search-forward literate-smalltalk-separator)
      (setf instance-code (buffer-substring-no-properties anchor-pos (line-beginning-position)))
      (setf class-code (buffer-substring-no-properties (line-end-position) (point-max))))
    (let* ((instance-data (literate-smalltalk-parse-subclass-definition instance-code))
           (class-data (literate-smalltalk-parse-class-definition class-code)))
      (unless instance-data
        (message "instance-code:'%s'" instance-code)
        (error "Failed to get subclass information."))
      (unless class-data
        (message "class-data: '%s'" class-code)
        (error "Failed to get class information."))
      (push (cons "comment" comment) instance-data)
      (let ((resp (literate-smalltalk-request
                   "compile/class"
                   :data `(("instance" . ,(json-encode instance-data))
                             ("class" . ,(json-encode class-data)))
                   :type "POST")))
        (message "Compile class %s." (cdr (assoc 'status resp)))))))
#+END_SRC
**** compile method
#+BEGIN_SRC elisp
(defface literate-smalltalk-correction-face
    '((((class mono)) (:inverse-video t :bold t :underline t))
      (t (:background "LightPink4" :bold t)))
  "Face used to visualize correction."
  :group 'literate-smalltalk)

(defun literate-smalltalk-compile-method (class side category code block-info)
  (unless class
    (error "Please specifiy the class of current method!"))
  (unless side
    (error "Please specifiy the side of current method!"))
  (unless category
    (error "Please specifiy the category of current method!"))
  (let* ((resp (literate-smalltalk-request
                "compile/method"
                :data `(("class" . ,class)
                          ("category" . ,category)
                          ("source" . ,code)
                          ("side" . ,side))
                :type "POST"))
         (result (cdr (assoc 'status resp)))
         (message (or (cdr (assoc 'message resp)) ""))
         (critiques (cdr (assoc 'critiques resp)))
         (begin (save-excursion
                  (goto-char (plist-get block-info :begin))
                  (forward-line)
                  (line-beginning-position)))
         (selector-end-position
           (save-excursion
             (goto-char (plist-get block-info :begin))
             (forward-line)
             (line-end-position)))
         (end (save-excursion
                  (goto-char (plist-get block-info :end))
                  (forward-line -1)
                  (line-end-position)))
         (overlay-in-first-line nil))
    (save-excursion
      (goto-char begin)
      (pm-set-buffer (point))
      (mapcar (lambda (ov)
                (when (overlay-get ov 'smalltalk-message)
                  (delete-overlay ov)))
              (overlays-in begin end))
      (mapcar (lambda (critique)
                ;; there may have multiple critiques for a method without range, we all put them in first line.
                (let* ((original-message nil)
                       (ov (if (and (cdr (assoc 'first critique))
                                    (null (overlays-in begin selector-end-position)))
                             (make-overlay (+ begin (cdr (assoc 'first critique)))
                                           (+ begin (cdr (assoc 'last critique))))
                             (if overlay-in-first-line
                               (prog1 overlay-in-first-line
                                      (setf original-message
                                              (concat (overlay-get overlay-in-first-line 'smalltalk-message) "\n")))
                               (setf overlay-in-first-line (make-overlay begin selector-end-position))))))
                  (overlay-put ov 'smalltalk-message (concat original-message (cdr (assoc 'message critique))))
                  (overlay-put ov 'help-echo (concat original-message (cdr (assoc 'message critique))))
                  (overlay-put ov 'face 'literate-smalltalk-correction-face)))
              critiques))
    (if (= 0 (length critiques))
      (message "Compile %s %s." result message)
      (message "Compile %s( %d critique) %s." result (length critiques) message))))
#+END_SRC
**** API request to format code
[[file:~/projects/smalltalk/pharo/src/Deprecated80/PluggableTextMorph.class.st::tree := RBParser parseMethod: source onError: \[ :msg :pos | ^ self \].][RBParser parseMethod]]
#+BEGIN_SRC elisp
(defun literate-smalltalk-format-code (code-start-point code type)
  (let ((resp (literate-smalltalk-request
               "format/code"
               :data `(("source" . ,(encode-coding-string code 'latin-1-mac))
                         ("type" . ,type))
               :type "POST")))
    (unless (string= "success" (cdr (assoc 'status resp)))
      (when (fixnump (cdr (assoc 'pos resp)))
        (goto-char (+ code-start-point (cdr (assoc 'pos resp)))))
      (error "Failed to format code at %s:%s!"
             (cdr (assoc 'pos resp))
             (cdr (assoc 'msg resp))))
    (decode-coding-string (cdr (assoc 'source resp)) 'latin-1-mac)))

#+END_SRC
**** API request to complete code at position
#+BEGIN_SRC elisp
(defun literate-smalltalk-request-complete-code (class source)
  (literate-smalltalk-request "completion/method"
                              :data `(("class" . ,(or class ""))
                                      ("source" . ,(encode-coding-string source 'latin-1-mac)))
                              :type "POST"))
#+END_SRC

**** API request to delete a class
#+BEGIN_SRC elisp
(defun literate-smalltalk-request-delete-class (class)
  (literate-smalltalk-request
   "remove/class"
   :type "GET"
   :params `(("class" . ,class))))
#+END_SRC
**** API request to delete a class method
#+BEGIN_SRC elisp
(defun literate-smalltalk-request-delete-class-method (class method side)
  (literate-smalltalk-request
   "method/remove"
   :type "GET"
   :params `(("class" . ,class)
             ("name" . ,method)
             ("side" . ,side))))
#+END_SRC
*** command to code format
#+BEGIN_SRC elisp
(defun literate-smalltalk-code-format-current-code-block ()
  (interactive)
  (let* ((context-info (second (org-element-context)))
         (block-arguments (third (org-babel-get-src-block-info)))
         (code (plist-get context-info :value))
         (code-start-point (save-excursion
                             (goto-char (plist-get context-info :begin))
                             (forward-line)
                             (line-beginning-position)))
         (type (aif (cdr (assoc :type block-arguments))
                 it
                 "method"))
         (formatted-code (literate-smalltalk-format-code code-start-point code type)))
    (replace-region-contents
     (plist-get context-info :begin)
     (plist-get context-info :end)
     (lambda ()
       (let* ((beg-src-line (progn (goto-char (point-min))
                                   (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))))
         (concat beg-src-line "\n"
                 formatted-code "\n"
                 "#+END_SRC\n"))))
    (message "format code done.")))
#+END_SRC


*** command to delete a class method
#+BEGIN_SRC elisp
(defun literate-smalltalk-delete-current-class-or-method ()
  (interactive)
  (let* ((context-info (second (org-element-context)))
         (info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (params (nth 2 info))
         (type (if (cdr (assq :type params))
                 (intern (cdr (assq :type params)))
                 (if (search "subclass: #" body)
                   'class
                   'method)))
         (resp (case type
                 (method
                  (literate-smalltalk-request-delete-class-method
                   (or (cdr (assq :class params))
                       (save-current-buffer
                         ;; have to switch to org buffer to access property value.
                         (pm-set-buffer (plist-get context-info :begin))
                         (org-entry-get (point) "literate-class" t)))
                   (literate-smalltalk-extract-selector (save-excursion
                                                          (goto-char (plist-get context-info :begin))
                                                          (forward-line)
                                                          (buffer-substring-no-properties
                                                           (line-beginning-position)
                                                           (line-end-position))))
                   (cdr (assq :side params))))
                 (class (literate-smalltalk-request-delete-class
                         (or (cdr (assq :class params))
                             (save-current-buffer
                               ;; have to switch to org buffer to access property value.
                               (pm-set-buffer (plist-get context-info :begin))
                               (org-entry-get (point) "literate-class" t))))))))
    (message "delete %s(%s)."
             (cdr (assoc 'status resp))
             (cdr (assoc 'message resp)))))
#+END_SRC

*** code completion with company mode
**** entry point
#+BEGIN_SRC elisp
(defun literate-smalltalk-completion-candidates ()
  (let* ((region (literate-smalltalk-current-symbol-region))
         (block-info (second (org-element-context)))
         (code-start-point (save-excursion
                             (goto-char (plist-get block-info :begin))
                             (forward-line)
                             (line-beginning-position)))
         (code (buffer-substring-no-properties code-start-point (point)))
         (resp (literate-smalltalk-request-complete-code
                (or (cdr (assq :class block-info))
                    (save-current-buffer
                      ;; have to switch to org buffer to access property value.
                      (pm-set-buffer (plist-get block-info :begin))
                      (org-entry-get (point) "literate-class" t)))
                code)))
    (if (string= "success" (cdr (assoc 'status resp)))
      (mapcar #'identity (cdr (assoc 'entities resp)))
      ;; we have to add a timer to report exception because in a company completion, it will use `unwind-protect'
      ;; and make our error message silient.
      (run-at-time "1 sec" nil
                   #'(lambda ()
                       (message "Fatal in pharo:%s"
                                (cdr (assoc 'message (request-response-data literate-smalltalk-last-response))))))
      nil)))
#+END_SRC
**** entry point for company mode
#+BEGIN_SRC elisp
(defun company-literate-smalltalk-code (command &optional arg &rest ignored)
  "`company-mode' completion backend for literate-smalltalk-code."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-literate-smalltalk-code))
    (prefix (literate-smalltalk-current-symbol-at-point))
    (candidates (literate-smalltalk-completion-candidates))))
(define-key literate-smalltalk-code-mode-map [(meta ?/)] 'company-literate-smalltalk-code)
(define-key literate-smalltalk-code-mode-map (kbd "TAB") 'company-literate-smalltalk-code)
#+END_SRC
*** Pharo
**** compile class
#+BEGIN_SRC smalltalk :side class :cat "compile"
compileClass: instDef class: classDef

	| parent class status instvars classvars |
	status := #success.
	instvars := ''.
	(instDef at: #instvars) ifNotNil: [
		instvars := self elementsString: (instDef at: #instvars) ].
	classvars := ''.
	(instDef at: #classvars) ifNotNil: [
		classvars := self elementsString: (instDef at: #classvars) ].

	"Looks a bit kludgy, but currently I dont know how to make it better. TODO: refactor"
	parent := Smalltalk at: (instDef at: #super) asSymbol.
	[
	class := parent
		         subclass: (instDef at: #name) asSymbol
		         instanceVariableNames: instvars
		         classVariableNames: classvars
		         poolDictionaries: ''
		         category: (instDef at: #package) ]
		on: Error
		do: [ :e |
			^ {
				  (#status -> #instFailed).
				  (#message -> e asString) } asDictionary ].
	class := Smalltalk at: (instDef at: #name) asSymbol ifAbsent: [ nil ].
	class comment: (instDef at: #comment).
	"On Pharo, there were a strange exception when using the safe form."
	instvars := ''.
	(classDef at: #instvars) ifNotNil: [
		instvars := self elementsString: (classDef at: #instvars) ].
	class class instanceVariableNames: instvars.
	^ { (#status -> status) } asDictionary
#+END_SRC
**** remove a class
#+BEGIN_SRC smalltalk :side class :cat "compile"
removeClass: className

	| class |
	class := Smalltalk at: className asSymbol ifAbsent: nil.
	class ifNil: [
		^ {
			  (#status -> #failed).
			  (#message -> 'class Not Found') } asDictionary ].
	class removeFromSystem.
	^ {
		  (#status -> #success).
		  (#message -> '') } asDictionary
#+END_SRC
**** compile method
#+BEGIN_SRC smalltalk :side class :cat "compile"
compileMethod: className category: cat source: source side: side

	| class status selector critiques message |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	status := #success.
	critiques := ''.
	selector := ''.
	message := ''.
	[
	selector := class compile: source classified: cat.
	critiques := (class >> selector) critiques collect: [ :critique |
		             | anchor first last |
		             anchor := critique sourceAnchor interval.
		             first := anchor ifNotNil: [ anchor first ].
		             last := anchor ifNotNil: [ anchor last ].
		             {
			             (#message -> critique asString).
			             (#first -> first).
			             (#last -> last) } asDictionary ] ]
		on: SyntaxErrorNotification , OCAbortCompilation , OCSemanticError , OCSemanticWarning
			, ReparseAfterSourceEditing
		do: [ :ex |
			message := ex asString.
			status := ex className ].
	^ {
		  (#status -> status).
		  (#message -> message).
		  (#selector -> selector).
		  (#critiques -> critiques) } asDictionary
#+END_SRC
**** remove a method
#+BEGIN_SRC smalltalk :side class :cat "compile"
removeSelector: className name: methodName side: side

	| class status message |
	class := Smalltalk at: className asSymbol.
	class := side = #class
		         ifTrue: [ class class ]
		         ifFalse: [ class ].
	status := #success.
	message := ''.
	[ class removeSelector: methodName asSymbol]
		on: Exception
		do: [ :ex |
			message := ex asString.
			status := ex className ].
	^ {
		  (#status -> status).
		  (#message -> message) } asDictionary
#+END_SRC
**** format code
#+BEGIN_SRC smalltalk :side class :cat "compile"
formatCode: source type: type

	| tree errBlock |
	errBlock := [ :msg :pos |
	            ^ {
		              (#status -> #failed).
		              (#msg -> msg).
		              (#pos -> pos) } asDictionary ].
	tree := type = 'code'
		        ifTrue: [ RBParser parseExpression: source onError: errBlock ]
		        ifFalse: [ RBParser parseMethod: source onError: errBlock ].
	^ {
		  (#status -> #success).
		  (#source -> tree formattedCode) } asDictionary
#+END_SRC
**** completion
#+BEGIN_SRC smalltalk :side class :cat "compile"
completion: className source: source

	| class context entities |
	class := Smalltalk at:
		         (className ifEmpty: [ #GTPlayground ] ifNotEmpty: [ className asSymbol ]).
	context := CompletionContext
		           engine: CompletionEngine new
		           class: class
		           source: source
		           position: source size.
	entities := context entries collect: [ :each | each contents ].
	^ {
		  (#status -> #success).
		  (#entities -> entities) } asDictionary
#+END_SRC
* Code navigation
The code navigation in pharo is straight-forward, there are only two concepts to lookup, a Class or a method.
** search a pattern in a buffer and return its position
#+BEGIN_SRC elisp
(defvar literate-smalltalk-libraries-literate-path "~/Pharo/literate/")
(defun literate-smalltalk-search-pattern (pattern)
  (save-restriction
    (loop for buf in (cons (current-buffer)
                           (mapcar 'find-file-noselect (directory-files literate-smalltalk-libraries-literate-path t ".org$")))
          do (with-current-buffer buf
               (save-excursion
                 (goto-char (point-min))
                 (when (re-search-forward pattern nil t)
                   (goto-char (line-beginning-position))
                   (org-ensure-point-visible)
                   (return (list (current-buffer) (point)))))))))
#+END_SRC
** find definition of class in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-class-definition (class-name)
  (literate-smalltalk-search-pattern (format "subclass: #%s" class-name)))
#+END_SRC
** find definition of a class method in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-method-definition (class-name method-name)
  (or (loop for buf in (cons (current-buffer)
                             (mapcar 'find-file-noselect (directory-files literate-smalltalk-libraries-literate-path t ".org$")))
            do (with-current-buffer buf
                 (save-excursion
                   (goto-char (point-min))
                   (pm-set-buffer (point))
                   (let (start end)
                     (if (re-search-forward (concat "#\\+PROPERTY:\\s+literate-class\\s+" class-name) nil t)
                       (setf start (point-min)
                             end (point-max))
                       (goto-char (point-min))
                       (when (re-search-forward (format ":literate-class:\s+%s" class-name) nil t)
                         (re-search-backward "^\\*")
                         (let ((block-info (second (org-element-context))))
                           (when (re-search-forward (concat "^\s*" method-name) (plist-get block-info :end) t)
                             (goto-char (line-beginning-position))
                             (org-ensure-point-visible)
                             (return (list (current-buffer) (point)))))))))))
      (literate-smalltalk-search-pattern (format ":class %s.*[\n\r]%s" class-name method-name))))
#+END_SRC
** get method name from method codes
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-name-from-source (source)
  (let* ((first-line (first (split-string body "[\n\r]+" t nil)))
         (items (split-string first-line "[ \t]+" t "[ \t]+")))
    (if (= 1 (length items))
      (first items)
      (with-temp-buffer
        (loop for item in items
              if (search ":" item)
                do (insert item))
        (buffer-string)))))
#+END_SRC
** basic idea
We will try to use [[http://geoff.greer.fm/ag/][silver searcher]] as the xref backend to search.
#+BEGIN_SRC elisp
(defun literate-smalltalk-xref-backend ()
  'xref-st)

(defun install-literate-smalltalk-xref-backend ()
  (make-local-variable 'xref-backend-functions)
  (setf xref-backend-functions '(literate-smalltalk-xref-backend)))
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-xref-backend)
#+END_SRC
** xref interfaces
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-identifier-at-point ((_backend (eql xref-st)))
  (literate-smalltalk-current-symbol-at-point))

(cl-defmethod xref-backend-definitions ((_backend (eql xref-st)) symbol)
  (literate-smalltalk--xref-find-definitions symbol))
#+END_SRC
** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk--xref-find-definitions (name)
  (interactive)
  (let* ((class? (<= ?A (aref name 0) ?Z))
         (class-name (unless class?
                       (literate-smalltalk-previous-symbol-at-point)))
         (buf-pos (if class?
                    (literate-smalltalk-find-class-definition name)
                    (literate-smalltalk-find-method-definition class-name name))))
    (when buf-pos
      (list (xref-make (if class?
                         name
                         (concat class-name ">>" name))
                       (xref-make-buffer-location (first buf-pos)
                                                (second buf-pos)))))))
#+END_SRC

* Update source
#+BEGIN_SRC elisp
(defun literate-smalltalk-update-source ()
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (params (nth 2 info))
         (block-info (second (org-element-context)))
         (type (if (cdr (assq :type params))
                 (intern (cdr (assq :type params)))
                 (if (search "subclass: #" body)
                   'class
                   'method)))
         (code (case type
                 (method
                     (literate-smalltalk-method-source
                      (or (cdr (assq :class params))
                          (save-current-buffer
                            ;; have to switch to org buffer to access property value.
                            (pm-set-buffer (plist-get block-info :begin))
                            (org-entry-get (point) "literate-class" t)))
                      (literate-smalltalk-method-name-from-source body)
                      (cdr (assq :side params))))
                 (class
                  (literate-smalltalk-class
                   (or (cdr (assq :name params))
                       (save-current-buffer
                         ;; have to switch to org buffer to access property value.
                         (pm-set-buffer (plist-get block-info :begin))
                         (org-entry-get (point) "literate-class" t)))))
                 (t
                  (error "Unknown supported type %s" type))))
         (body (and code (decode-coding-string code 'latin-1-mac))))
    (when body
      (let ((block-info (second (org-element-context))))
        (replace-region-contents (plist-get block-info :begin)
                                 (plist-get block-info :end)
                                 (lambda ()
                                   (let* ((beg-src-line (progn (goto-char (point-min))
                                                               (buffer-substring-no-properties
                                                                (line-beginning-position)
                                                                (line-end-position)))))
                                     (concat beg-src-line "\n"
                                             body "\n"
                                             "#+END_SRC\n"))))
        (message "update source done.")))))
#+END_SRC
* imports codes to org file
** Import codes of namespaces to org mode
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-to-org-section (&optional namespaces)
  (interactive)
  (let ((namespaces (or namespaces (literate-smalltalk-select-namespace))))
    (unless (listp namespaces)
      (setf namespaces (list namespaces)))
    (cl-loop with count-of-namespaces = (length namespaces)
             for index from 1
             for namespace in namespaces
             do (newline)
             (insert "* PACKAGE " namespace)
             (newline)
             (loop for class in (literate-smalltalk-classes namespace)
                   for categories-dict = (literate-smalltalk-categories class)
                   do (insert "** CLASS " class)
                      (newline)
                      (insert ":PROPERTIES:")
                      (newline)
                      (insert ":literate-class:    " class)
                      (newline)
                      (insert ":END:")
                      (newline)
                      (insert "*** CLASS DEFINITION")
                      (newline)
                      (insert "#+BEGIN_SRC smalltalk")
                      (newline)
                      (insert (literate-smalltalk-class class))
                      (newline)
                      (insert "#+END_SRC")
                      (newline)
                      (loop for side in '("class" "instance")
                            for side-symbol = (intern side)
                            do (loop for category across (cdr (assoc side-symbol categories-dict))
                                     for normalized-category = (replace-regexp-in-string
                                                                       " " "@" category)
                                     do (loop for method in (literate-smalltalk-category-methods
                                                                     class category side)
                                              for source = (literate-smalltalk-method-source
                                                                  class method side)
                                              if (not (literate-smalltalk-autogenerated-code? source))
                                              do (insert "*** METHOD "
                                                         method "                                            "
                                                                side
                                                         ":" normalized-category ":")
                                                 (newline)
                                                 (insert "#+BEGIN_SRC smalltalk"
                                                         " :class " class
                                                         " :side " side
                                                         " :cat \"" category "\"")
                                                 (newline)
                                                 (insert source)
                                                 (newline)
                                                 (insert "#+END_SRC")
                                                 (newline)
                                                 (sit-for 0)))))
             (message "namespace '%s'(%d/%d) has been added." namespace index count-of-namespaces))))
#+END_SRC
** Import codes of packages to org mode
#+BEGIN_SRC elisp
(defun literate-smalltalk-package-to-org-section (&optional packages)
  (interactive)
  (let ((packages (or packages (literate-smalltalk-select-package))))
    (unless (listp packages)
      (setf packages (list packages)))
    (cl-loop with count-of-packages = (length packages)
             for index from 1
             for package in packages
             for tags = (literate-smalltalk-package-tags package)
             for extensions = (literate-smalltalk-package-extensions package)
             do (newline)
             (insert "* PACKAGE " package)
             (newline)
             (loop for tag across tags
                   do (insert "** TAG " (cdr (assoc 'name tag)))
                      (newline)
                      (loop for class across (cdr (assoc 'classes tag))
                            for categories-dict = (literate-smalltalk-categories class)
                            do (insert "*** CLASS " class)
                               (newline)
                               (insert ":PROPERTIES:")
                               (newline)
                               (insert ":literate-class:    " class)
                               (newline)
                               (insert ":END:")
                               (newline)
                               (insert "**** CLASS DEFINITION")
                               (newline)
                               (insert "#+BEGIN_SRC smalltalk")
                               (newline)
                               (insert (literate-smalltalk-class class))
                               (newline)
                               (insert "#+END_SRC")
                               (newline)
                               (loop for side in '("class" "instance")
                                     for side-symbol = (intern side)
                                     do (loop for category across (cdr (assoc side-symbol categories-dict))
                                              for normalized-category = (replace-regexp-in-string
                                                                                " " "@" category)
                                              do (loop for method in (literate-smalltalk-category-methods
                                                                              class category side)
                                                       for source = (literate-smalltalk-method-source
                                                                             class method side)
                                                       if (not (literate-smalltalk-autogenerated-code? source))
                                                         do (insert "**** METHOD "
                                                                    method "                                            "
                                                                           side
                                                                    ":" normalized-category ":")
                                                            (newline)
                                                            (insert "#+BEGIN_SRC smalltalk"
                                                                    " :class " class
                                                                    " :side " side
                                                                    " :cat \"" category "\"")
                                                            (newline)
                                                            (insert source)
                                                            (newline)
                                                            (insert "#+END_SRC")
                                                            (newline)
                                                            (sit-for 0))))))
             (cl-loop initially (when (> (length extensions) 0)
                                  (insert "** Extensions ")
                                  (newline))
              for extension across extensions
                      do (insert "*** " (cdr (assoc 'name extension)))
                      (newline)
                      (insert "#+BEGIN_SRC smalltalk"
                              " :class " (cdr (assoc 'class extension))
                              " :side " (cdr (assoc 'side extension))
                              " :cat \"" (cdr (assoc 'category extension)) "\"")
                      (newline)
                      (insert (decode-coding-string (cdr (assoc 'code extension)) 'latin-1-mac))
                      (newline)
                      (insert "#+END_SRC")
                      (newline))
             (message "package '%s'(%d/%d) has been added." package index count-of-packages))))
#+END_SRC
* babel support
** optionally define a file extension for this language
#+BEGIN_SRC elisp
(add-to-list 'org-babel-tangle-lang-exts '("smalltalk" . "smalltalk"))
#+END_SRC
** optionally declare default header arguments
#+BEGIN_SRC elisp
(defvar org-babel-default-header-args:smalltalk '())
#+END_SRC
** Source Code Execution
*** babel entry
This is the main function which is called to evaluate a code block.

This function will evaluate the body of the source code and
return the results as emacs-lisp depending on the value of the
=:results= header argument

All header arguments specified by the user will be available in the =PARAMS= variable.
#+BEGIN_SRC elisp
(defun org-babel-execute:smalltalk (body params)
  "Execute a block of smalltalk code with org-babel.
This function is called by `org-babel-execute-src-block',
Argument BODY: the code body
Argument PARAMS: the input parameters."
  (let* ((result-params (cdr (assq :result-params params)))
         (results (literate-smalltalk-execute-code-block body params)))
    (unless (stringp results)
      (setf results (format "%s" results)))
    (decode-coding-string results 'latin-1-mac)))
#+END_SRC
*** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-code-block (body params)
  (let ((type (if (cdr (assq :type params))
                (intern (cdr (assq :type params)))
                (if (search "subclass: #" body)
                  'class
                  'method)))
        (side (cdr (assq :side params)))
        (block-info (second (org-element-context)))
        (code (encode-coding-string body 'latin-1-mac)))
    (case type
      (code (literate-smalltalk-eval code (not (null current-prefix-arg))))
      (method
       (literate-smalltalk-compile-method
        (or (cdr (assq :class params))
            (save-current-buffer
              ;; have to switch to org buffer to access property value.
              (pm-set-buffer (plist-get block-info :begin))
              (org-entry-get (point) "literate-class" t)))
        side
        (cdr (assq :cat params))
        code block-info))
      (class
       (literate-smalltalk-compile-class body))
      (t
       (error "Unknown type %s" type)))))
#+END_SRC
** execute all source codes in current header
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-current-header ()
  (interactive)
  (let* ((element (org-element-at-point))
         (info (second element))
         (begin (plist-get info :begin))
         (end (plist-get info :end)))
    (if current-prefix-arg
      (setf end (point-max))
      (unless (eq 'headline (first element))
        (error "Please move point to a headline.")))
    (goto-char begin)
    (while (search-forward "#+BEGIN_SRC smalltalk" end t)
      (unless (search ":type code" (buffer-substring-no-properties (line-beginning-position)
                                                                   (line-end-position)))
        (org-babel-execute-src-block-maybe)))))
#+END_SRC
** execute source codes in current code block
We have to switch back to org buffer, otherwise =org-babel-execute-src-block-maybe= will report a message and
override our own compilation report.
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-current-code-block ()
  (interactive)
  (let* ((element (org-element-at-point))
         (info (second element))
         (begin (plist-get info :begin)))
    (save-excursion
      (goto-char begin)
      (pm-set-buffer (point))
      (org-babel-execute-src-block-maybe))))
#+END_SRC

* Release to pharo
#+BEGIN_SRC smalltalk :type code
| file |
file := ((OSEnvironment current at: #HOME), '/projects/literate-smalltalk/LiterateSmalltalk/LiterateServer.class.st') asFileReference.
file exists ifTrue: [ file delete ].
file
	writeStreamDo: [ :s | TonelWriter exportClass: LiterateServer on: s ];
	yourself
#+END_SRC
* Test
** eval codes
:PROPERTIES:
:results:  value
:END:
#+BEGIN_SRC smalltalk :type code :results raw
| y |
y := Dictionary new.
y at: 'page' put: '2'.
y
#+END_SRC
** ban some critiques rules
#+BEGIN_SRC smalltalk :type code
{ #RBBadMessageRule. #ReBadMessageRule. #RBImplementedNotSentRule. #ReImplementedNotSentRule.
 #RBUtilityMethodsRule. #ReUtilityMethodsRule. #ReUncommonMessageSendRule}
	do: [ :name |
		| class |
		class := Smalltalk at: name ifAbsent: [ nil ].
		class ifNotNil: [ class enabled: false ]
		]
#+END_SRC
** test
#+BEGIN_SRC smalltalk :type code
Metacello new
		    baseline: 'LiterateSmalltalk';
		    repository: 'filetree:///home/jingtao/projects/literate-smalltalk/';
		    onConflict: [ :ex | ex allow ];
		    load.
(Metacello image baseline: 'LiterateSmalltalk') list first repositories list first spec description.
#+END_SRC
