# -*- encoding:utf-8 Mode: POLY-ORG; org-src-preserve-indentation: t; -*- ---
#+TITLE:  Literate programming tool write smalltalk in org mode.
#+SubTitle: based on shampoo.
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+LATEX_HEADER: % copied from lstlang1.sty, to add new language support to Emacs Lisp.
#+LATEX_HEADER: \lstdefinelanguage{elisp}[]{lisp} {}
#+LATEX_HEADER: \lstloadlanguages{elisp}
#+PROPERTY: header-args
#+PROPERTY: literate-lang elisp
#+PROPERTY: literate-load yes

* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#preparation][Preparation]]
- [[#how-to-do-it-01][How to do it?]]
- [[#emacs-side][Emacs side]]
  - [[#utilities][utilities]]
    - [[#receive-response-from-pharo][receive response from pharo.]]
    - [[#synchronous-call-to-shampoo][synchronous call to shampoo]]
    - [[#update-shampoo-side][update shampoo side]]
    - [[#forward-to-begin-of-function][forward to begin of function]]
    - [[#current-symbol-at-point][current symbol at point]]
    - [[#previous-symbol-at-point][previous symbol at point]]
  - [[#apis][APIs]]
    - [[#api-request][api request]]
    - [[#get-namespaces][get namespaces]]
    - [[#get-classes-of-one-namespace][get classes of one namespace]]
    - [[#cache-for-classes-as-index][cache for classes as index]]
    - [[#get-namespace-of-one-class][get namespace of one class]]
    - [[#print-out-class-definition][print out class definition]]
    - [[#get-class-definition][get class definition]]
    - [[#get-categories-of-one-class][get categories of one class]]
    - [[#get-methods-of-one-category][get methods of one category]]
    - [[#get-method-source][get method source]]
    - [[#eval-code][eval code]]
    - [[#compile-class][compile class]]
    - [[#compile-method][compile method]]
    - [[#format-code][format code]]
    - [[#search-a-pattern-in-a-buffer-and-return-its-position][search a pattern in a buffer and return its position]]
    - [[#find-definition-of-class-in-org-files][find definition of class in org files]]
    - [[#find-definition-of-a-class-method-in-org-files][find definition of a class method in org files]]
  - [[#fetch-all-source-of-a-package-to-an-org-section][Fetch all source of a package to an org section.]]
  - [[#update-codes][update codes]]
  - [[#jump-to-implementations][jump to implementations.]]
    - [[#basic-idea][basic idea]]
    - [[#xref-interfaces][xref interfaces]]
    - [[#implementation][implementation]]
  - [[#babel-support][babel support]]
    - [[#optionally-define-a-file-extension-for-this-language][optionally define a file extension for this language]]
    - [[#optionally-declare-default-header-arguments][optionally declare default header arguments]]
    - [[#source-code-execution][Source Code Execution]]
  - [[#test][Test]]
    - [[#eval-codes][eval codes]]
- [[#pharo-side][Pharo side]]
  - [[#a-teapot-server-to-handle-request][a Teapot server to handle request]]
    - [[#definition][definition]]
    - [[#the-server-accessor][the Server accessor]]
    - [[#how-to-start-the-server][how to start the server]]
    - [[#get-namespaces-1][get namespaces]]
    - [[#get-classes-of-one-namespace-1][get classes of one namespace]]
    - [[#get-class-information][get class information]]
    - [[#get-class-categories][get class categories]]
    - [[#get-methods-in-one-class-category][get methods in one class category]]
    - [[#get-method-source-1][get method source]]
    - [[#get-method-source-2][get method source]]
    - [[#compile-method-1][compile method]]

* Introduction
This is an attemp to write smalltalk codes in org mode,
and interact with remote [[https://pharo.org/][pharo]] images based on [[https://github.com/dmatveev/shampoo-emacs][shampoo]].
* Preparation
You need to install [[https://github.com/jingtaozf/shampoo-pharo.git][shampo for pharo]] in pharo and start shampo server by the following codes
#+begin_src st
ShampooServer startOn: 9092 login: 'login' pass: '1234'.
#+end_src
Then you can install [[https://github.com/dmatveev/shampoo-emacs][shampoo for Emacs]] and connect to this server by command =shampoo-connect=,
and argument =login@localhost:9092=, password =1234=.

* How to do it? [0/1]
We interact with pharo via shampoo, and hack shampoo to fetch/update codes in an org file.

- [ ] Find packages's sub category
  https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Extensions.md#define-an-extension-method-programmatically

* Emacs side
** utilities
*** receive response from pharo.
We use an advice function to hood the response sent to pharo.

To simplify our process, we will disable old shampoo response handler under our invocation.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-shampoo-p t)
#+END_SRC
We will set this variable to =nil= before sending our message and reset it to =t= after getting response.
The default value of it is =t= so our invocation will not affect original shampoo operations.

We use a special variable to hold our response result.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-current-response nil)
(defvar literate-smalltalk-last-response nil)
#+END_SRC

#+BEGIN_SRC elisp
(defun literate-smalltalk-shampoo-handle-response (old-function resp)
  (if literate-smalltalk-shampoo-p
    (funcall old-function resp)
    (setf literate-smalltalk-current-response resp)))

(eval-after-load "shampoo"
  '(advice-add 'shampoo-handle-response :around #'literate-smalltalk-shampoo-handle-response))
#+END_SRC
*** synchronous call to shampoo
#+BEGIN_SRC elisp
(defun literate-smalltalk-shampoo-call (message)
  (setf literate-smalltalk-current-response nil
        literate-smalltalk-shampoo-p nil)
  (with-~shampoo~
      (shampoo-send-message
       message))
  (cl-loop for i from 0 to 100
           if literate-smalltalk-current-response
           do (return)
           else do (sit-for 0.1))
  (unless literate-smalltalk-current-response
    (error "Failed to get response from shampoo."))
  (setf literate-smalltalk-last-response literate-smalltalk-current-response
        literate-smalltalk-current-response nil
        literate-smalltalk-shampoo-p t)
  literate-smalltalk-last-response)
#+END_SRC
*** update shampoo side
#+BEGIN_SRC elisp
(defvar literate-smalltalk-valid-sides '(:class :instance))
(defun literate-smalltalk-update-side (side)
  (assert (find side literate-smalltalk-valid-sides))
  (with-~shampoo~
      (setf (shampoo-current-side ~shampoo~) side)))
#+END_SRC
*** forward to begin of function
#+BEGIN_SRC elisp
(defun literate-smalltalk-beginning-of-defun-function (arg)
  (if (> arg 0)
    (progn
      (search-backward "#+BEGIN_SRC ")
      (forward-line))
    (literate-smalltalk-end-of-defun-function)))

(defun literate-smalltalk-end-of-defun-function (arg)
  (search-forward "#+END_SRC")
  (forward-line -1))

(defun install-literate-smalltalk-beginning-of-defun-function ()
  (make-local-variable 'beginning-of-defun-function)
  (make-local-variable 'end-of-defun-function)
  (setf beginning-of-defun-function 'literate-smalltalk-beginning-of-defun-function)
  (setf end-of-defun-function 'literate-smalltalk-end-of-defun-function)
  )
(add-hook 'shampoo-code-mode-hook 'install-literate-smalltalk-beginning-of-defun-function)
#+END_SRC
*** current symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-at-point ()
  (save-excursion
    (let* ((beg (re-search-backward "[ \t\n(^[]" nil t))
           (end (progn
                  (forward-char)
                  (re-search-forward "[ \t\n\.]" nil t)
                  (backward-char)
                  (point))))
      (string-trim (buffer-substring-no-properties beg end) "[ \t\n\r(^]+"))))
#+END_SRC
*** previous symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-previous-symbol-at-point ()
  (save-excursion
    (re-search-backward "[ \t\n]" nil t)
    (forward-word -1)
    (literate-smalltalk-current-symbol-at-point)))
#+END_SRC

** APIs
*** api request
#+BEGIN_SRC elisp
(defvar literate-smalltalk-rest-server "http://localhost:9092/")
(defvar literate-smalltalk-last-response nil)
(cl-defun literate-smalltalk-request (path &key params data (type "GET"))
  (let ((resp nil))
    (request (concat literate-smalltalk-rest-server path)
        :params params
        :parser 'json-read
        :type type
        :sync t
        :data data
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-smalltalk-last-response response)
                     (unless (equal 200 (request-response-status-code response))
                       (error "Failed to request to remote pharo:%s" response))
                     (setf resp (request-response-data response)))))
    resp))
#+END_SRC
*** get namespaces
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespaces ()
  (cdr (assoc 'namespaces (literate-smalltalk-request "namespaces"))))

(defun literate-smalltalk-select-namespace ()
  (helm-select-list "Please select a namespace: " (literate-smalltalk-namespaces)))
#+END_SRC
*** get classes of one namespace
#+BEGIN_SRC elisp
(defun literate-smalltalk-classes (namespace)
  (cdr (assoc 'classes (literate-smalltalk-request (concat "classes/" namespace)))))

(defun literate-smalltalk-select-a-class (namespace)
  (helm-select-list "Please select a namespace: " (literate-smalltalk-classes namespace)))
#+END_SRC
*** cache for classes as index
It is slow to build such indexed from remote pharo, let store it to a global variable and cache it to local file.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-indexed-classes-file "~/.emacs.d/smalltalk.classes.txt")
(defvar literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
(defun literate-smalltalk-index-classes ()
  (interactive)
  (loop for namespace in (literate-smalltalk-namespaces)
        do (message "Indexing %s" namespace)
           (loop for class in (literate-smalltalk-classes namespace)
                 do (setf (gethash class literate-smalltalk-indexed-classes) namespace)))
  (with-current-buffer (find-file-noselect literate-smalltalk-indexed-classes-file)
    (erase-buffer)
    (fundamental-mode)
    (maphash (lambda (k v)
               (insert k " " v "\n"))
             literate-smalltalk-indexed-classes)
    (save-buffer)
    (kill-current-buffer)))

(defun literate-smalltalk-restore-indexed-classes ()
  (interactive)
  (message "start restoring...")
  (setf literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
  (cl-loop for line in (s-split "\n" (f-read literate-smalltalk-indexed-classes-file) t)
           for items = (s-split " " line)
           do (setf (gethash (car items) literate-smalltalk-indexed-classes) (second items)))
  (message "restoring...done"))
#+END_SRC
*** get namespace of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-of-a-class (class)
  (when (= 0 (hash-table-count literate-smalltalk-indexed-classes))
    (error "Please build the cache before use namespace of a class."))
  (gethash class literate-smalltalk-indexed-classes))

(defun literate-smalltalk-namespace-of-current-symbol ()
  (interactive)
  (let ((class (thing-at-point 'symbol)))
    (message "%s's namespace is %s" class (literate-smalltalk-namespace-of-a-class class))))
#+END_SRC

*** print out class definition
#+BEGIN_SRC elisp
(defconst literate-smalltalk-class-template
  '(("instanceVariableNames:" . instvars)
    ("classVariableNames:"    . classvars)
    ("poolDictionaries:"      . poolvars)))

(defconst literate-smalltalk-class-side-template
  '(("instanceVariableNames:" . instvars)))
(defvar literate-smalltalk-separator "----------------------")

(defun literate-smalltalk-class-definition-string (resp)
  (let ((instance (cdr (assoc 'instance resp)))
        (class (cdr (assoc 'class resp))))
    (with-temp-buffer
      (insert
       (format "%s subclass: #%s"
               (cdr (assoc 'superclass instance))
               (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (insert (format
               "    category: '%s'"
               ;; TODO:
               ""))
      (newline)
      (insert literate-smalltalk-separator)
      (newline)

      (insert (format "%s class" (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-side-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (trim-string (buffer-string)))))
#+END_SRC
*** get class definition
#+BEGIN_SRC elisp
(defun literate-smalltalk-class (class)
  (literate-smalltalk-class-definition-string (literate-smalltalk-request (concat "class/" class))))
#+END_SRC

*** get categories of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-categories (namespace class side)
  (literate-smalltalk-request (concat "cats/" class)))

;; (defun literate-smalltalk-select-a-category (namespace class)
;;   (helm-select-list "Please select a namespace: " (literate-smalltalk-categories namespace class)))
#+END_SRC
*** get methods of one category
#+BEGIN_SRC elisp
(defun literate-smalltalk-category-methods (class category side)
  (cdr (assoc 'methods (literate-smalltalk-request "cat/methods"
                                                   :params `(("class" . ,class)
                                                             ("cat" . ,category)
                                                             ("side" . ,side))))))
#+END_SRC
*** get method source
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-source (class method side)
  (let ((source (cdr (assoc 'source (literate-smalltalk-request
                                     "method/source"
                                     :params `(("class" . ,class)
                                               ("name" . ,method)
                                               ("side" . ,side)))))))
    (decode-coding-string source 'latin-1)))
#+END_SRC
*** eval code
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval (code)
  (let ((resp (literate-smalltalk-request
                                     "eval"
                                     :type "POST"
                                     :params `(("code" . ,code)))))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'result resp))
      (error "Failed to eval code!"))))
#+END_SRC
*** compile class
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-class (ns side code)
  (with-~shampoo~
      (setf (shampoo-current-side ~shampoo~) side))
  (let ((class-data (if (equal :class side)
                      (shampoo-parse-class-side-message code)
                      (shampoo-parse-subclassing-message code))))
    (case side
      (:instance
       (multiple-value-bind (superspace superclass)
           (let ((info
                  (with-~shampoo~
                      (shampoo-dialect-extract-parent
                       (shampoo-current-smalltalk ~shampoo~)
                       (shampoo-dict-get :super class-data)))))
             (multiple-value-bind (superspace superclass) info
               (values (if (null superspace)
                         ns
                         superspace)
                       superclass)))
         (shampoo-dict-put
          :key   :super
          :value superclass
          :into  class-data)
         (let ((resp (literate-smalltalk-shampoo-call
                      (shampoo-make-compile-instance-rq
                       :id (shampoo-give-id)
                       :ss superspace
                       :side (shampoo-side)
                       :ns ns
                       :cat (shampoo-dict-get :category class-data)
                       :desc class-data))))
           (if (shampoo-response-is-success resp)
             (message "Compile class done.")
             (message "Compile class failed.")))))
      (:class
       (let ((resp (literate-smalltalk-shampoo-call
                    (shampoo-make-compile-class-rq
                     :id (shampoo-give-id)
                     :ss "Smalltalk"
                     :side (shampoo-side)
                     :ns ns
                     :desc class-data))))
         (if (shampoo-response-is-success resp)
           (message "Compile class done.")
           (message "Compile class failed.")))))))
#+END_SRC
*** compile method
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-method (ns class side category code)
  (let ((resp (literate-smalltalk-request
               "compile/method"
               :params `(("class" . ,class)
                       ("source" . ,code)
                       ("side" . ,(shampoo-side-sym-as-param side)))
               :type "POST")))
    (message "Compile method %s." (cdr (assoc 'result resp)))
    ))
#+END_SRC

*** format code
[[file:~/projects/smalltalk/pharo/src/Deprecated80/PluggableTextMorph.class.st::tree := RBParser parseMethod: source onError: \[ :msg :pos | ^ self \].][RBParser parseMethod]]
*** search a pattern in a buffer and return its position
#+BEGIN_SRC elisp
(defvar literate-smalltalk-libraries-literate-path "~/Pharo/literate/")
(defun literate-smalltalk-search-pattern (pattern)
  (save-restriction
    (loop for buf in (cons (current-buffer)
                           (mapcar 'find-file-noselect (directory-files literate-smalltalk-libraries-literate-path t ".org$")))
          do (with-current-buffer buf
               (save-excursion
                 (goto-char (point-min))
                 (when (re-search-forward pattern nil t)
                   (forward-line)
                   (goto-char (line-beginning-position))
                   (return (list (current-buffer) (point)))))))))
#+END_SRC

*** find definition of class in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-class-definition (class-name)
  (literate-smalltalk-search-pattern (format ":type class :name %s " class-name)))
#+END_SRC
*** find definition of a class method in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-method-definition (class-name method-name)
  (literate-smalltalk-search-pattern (format ":type method :name %s.*? :class %s" method-name class-name)))
#+END_SRC

** Fetch all source of a package to an org section.
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-to-org-section (&optional namespaces)
  (interactive)
  (let ((namespaces (or namespaces (literate-smalltalk-select-namespace))))
    (unless (listp namespaces)
      (setf namespaces (list namespaces)))
    (cl-loop for namespace in namespaces
             do (insert "\n* PACKAGE " namespace "\n")
             (loop for class in (literate-smalltalk-classes namespace)
                   do (insert "** CLASS " class "\n")
                      (insert "*** CLASS DEFINITION \n")
                      (insert "#+BEGIN_SRC st :type class :name " class
                              " :ns " namespace "\n")
                      (insert (literate-smalltalk-class class))
                      (insert "\n#+END_SRC\n")
                      (loop for side in literate-smalltalk-valid-sides
                            for side-name = (shampoo-side-sym-as-param side)
                            for categories-dict = (literate-smalltalk-categories class)
                            do (loop for side in literate-smalltalk-valid-sides
                                     for side-symbol = (intern (subseq (symbol-name side) 1))
                                     do (loop for category in (cdr (assoc side-symbol categories-dict))
                                              for normalized-category = (replace-regexp-in-string " " "@" category)
                                              do (loop for method in (literate-smalltalk-category-methods
                                                                              class category side)
                                                       do (insert "*** METHOD "
                                                                  method "                                            "
                                                                         (symbol-name side)
                                                                  ":" normalized-category ":" "\n")
                                                          (insert "#+BEGIN_SRC st :type method"
                                                                  " :name " method
                                                                  " :class " class
                                                                  " :side " side-name
                                                                  " :cat \"" category "\""
                                                                  " :ns " namespace "\n")
                                                          (insert (literate-smalltalk-method-source
                                                                           class method side))
                                                          (insert "\n#+END_SRC\n"))))))
             (message "namedspace '%s' has been added." namespace))))
#+END_SRC
** update codes
#+BEGIN_SRC elisp
(defun literate-smalltalk-update-source ()
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (params (nth 2 info))
         (type (intern (concat ":" (cdr (assq :type params)))))
         (side (if (cdr (assq :side params))
                 (intern (concat ":" (cdr (assq :side params))))
                 :instance))
         (code (case type
                 (:method
                     (literate-smalltalk-method-source
                      (cdr (assq :class params))
                      (cdr (assq :name params))
                      side))
                 (:class
                  (literate-smalltalk-class (cdr (assq :name params))))
                 (t
                  (error "Unknown supported type %s" type))))
         (body (and code (decode-coding-string code 'latin-1))))
    (when body
      (let ((block-info (second (org-element-context))))
        (replace-region-contents (plist-get block-info :begin)
                                 (plist-get block-info :end)
                                 (lambda ()
                                   (let* ((beg-src-line (progn (goto-char (point-min))
                                                               (buffer-substring-no-properties
                                                                (line-beginning-position)
                                                                (line-end-position)))))
                                     (concat beg-src-line "\n"
                                             body "\n"
                                             "#+END_SRC\n"))))))))
#+END_SRC
** jump to implementations.
*** basic idea
We will try to use [[http://geoff.greer.fm/ag/][silver searcher]] as the xref backend to search.
#+BEGIN_SRC elisp
(defun literate-smalltalk-xref-backend ()
  'xref-st)

(defun install-literate-smalltalk-xref-backend ()
  (make-local-variable 'xref-backend-functions)
  (setf xref-backend-functions '(literate-smalltalk-xref-backend)))
(add-hook 'shampoo-code-mode-hook 'install-literate-smalltalk-xref-backend)
#+END_SRC
*** xref interfaces
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-identifier-at-point ((_backend (eql xref-st)))
  (literate-smalltalk-current-symbol-at-point))

(cl-defmethod xref-backend-definitions ((_backend (eql xref-st)) symbol)
  (literate-smalltalk--xref-find-definitions symbol))
#+END_SRC
*** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk--xref-find-definitions (name)
  (interactive)
  (let* ((class? (<= ?A (aref name 0) ?Z))
         (class-name (unless class?
                       (literate-smalltalk-previous-symbol-at-point)))
         (buf-pos (if class?
                    (literate-smalltalk-find-class-definition name)
                    (literate-smalltalk-find-method-definition class-name name))))
    (when buf-pos
      (list (xref-make (if class?
                         name
                         (concat class-name ">>" name))
                       (xref-make-buffer-location (first buf-pos)
                                                (second buf-pos)))))))
#+END_SRC

** babel support
*** optionally define a file extension for this language
#+BEGIN_SRC elisp
(add-to-list 'org-babel-tangle-lang-exts '("st" . "st"))
#+END_SRC
*** optionally declare default header arguments
#+BEGIN_SRC elisp
(defvar org-babel-default-header-args:st '())
#+END_SRC
*** Source Code Execution
**** babel entry
This is the main function which is called to evaluate a code block.

This function will evaluate the body of the source code and
return the results as emacs-lisp depending on the value of the
=:results= header argument

All header arguments specified by the user will be available in the =PARAMS= variable.
#+BEGIN_SRC elisp
(defun org-babel-execute:st (body params)
  "Execute a block of smalltalk code with org-babel.
This function is called by `org-babel-execute-src-block',
Argument BODY: the code body
Argument PARAMS: the input parameters."
  (let* ((result-params (cdr (assq :result-params params)))
         (results (literate-smalltalk-execute-code-block body params)))
    (when results
      (org-babel-result-cond result-params
        results
        (let ((tmp-file (org-babel-temp-file "q-")))
          (with-temp-file tmp-file (insert results))
          (org-babel-import-elisp-from-file tmp-file))))))
#+END_SRC
**** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-code-block (body params)
  (let ((type (intern (concat ":" (cdr (assq :type params)))))
        (side (if (cdr (assq :side params))
                (intern (concat ":" (cdr (assq :side params))))
                :instance))
        (code (encode-coding-string body 'latin-1)))
    (case type
      (:code (literate-smalltalk-eval code))
      (:method
          (literate-smalltalk-compile-method
           (cdr (assq :ns params))
           (cdr (assq :class params))
           side
           (cdr (assq :cat params))
           code))
      (:class
       (literate-smalltalk-compile-class
        (cdr (assq :ns params))
        side
        code))
      (t
       (error "Unknown type %s" type)))))
#+END_SRC

** Test
*** eval codes
:PROPERTIES:
:results:  value
:END:
#+BEGIN_SRC st :type code :results raw
y := Dictionary new.
y at: 'page' put: '2'.
(IsInteger matchesTo: (y at: 'page'))
   ifTrue: [ (y at: 'page') IsInteger parseString (y at: 'page')]
   ifFalse: 1.
#+END_SRC
* Pharo side
:PROPERTIES:
:literate-ns:    LiterateSmalltalk
:END:
** a Teapot server to handle request
:PROPERTIES:
:literate-lang: st
:literate-namespace:    LiterateSmalltalk
:literate-class:    LiterateServer
:END:
*** definition
#+BEGIN_SRC st :type class :name LiterateServer :ns LiterateSmalltalk
Object subclass: #LiterateServer
    instanceVariableNames: ''
    classVariableNames: 'Server Started'
    poolDictionaries: ''
    category: ''
----------------------
LiterateServer class
    instanceVariableNames: ''
#+END_SRC
*** the Server accessor
**** reader
#+BEGIN_SRC st :type method :name server :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
server
	"returns teapot instance"
	^ Server
#+END_SRC
**** writer
#+BEGIN_SRC st :type method :name server: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
server: server
	"sets teapot for class"
	Server := server.
#+END_SRC
*** how to start the server
#+BEGIN_SRC st :type method :name start :class LiterateServer :side class :cat "management" :ns LiterateSmalltalk
start
	"Start the webserver"

	| teapot |
	Teapot stopAll. "reset everything"

	"extra check so that we don't close a Pool which wasn't open"
	"Started ifNotNil: [ Started ifTrue: [ Server  stop ] ]."
	teapot := Teapot configure: {
			          (#defaultOutput -> #json).
			          (#port -> 9092).
			          (#debugMode -> true).
			          (#bindAddress -> #[ 127 0 0 1 ]) }.
	self server: teapot.
	teapot
	   GET: '/namespaces' -> [:req | self namespaces ];
	   GET: '/classes/<namespace>' -> [:req | self classes: (req at: #namespace) ];
	   GET: '/class/<class>' -> [:req | self classDef: (req at: #class) ];
	   GET: '/cats/<class>' -> [:req | self classCats: (req at: #class) ];
	   GET: '/cat/methods' -> [:req |
		self catMethods: (req at: #class)
		       category: (req at: #cat)
		       side: (req at: #side)
	    ];
	   GET: '/method/source' -> [:req |
		self methodSource: (req at: #class)
		       name: (req at: #name)
		       side: (req at: #side)
	    ];
	   POST: '/eval' -> [:req | self evalCode: (req at: #code)];
	   POST: '/compile/method' -> [:req |
		    self compileMethod: (req at: #class)
				source: (req at: #source)
				side: (req at: #side) ];
	   exception: KeyNotFound -> (TeaResponse notFound body: 'No such method');
	   start.

	Started := true.

#+END_SRC
*** get namespaces
#+BEGIN_SRC st :type method :name namespaces :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
namespaces
    | names |

    names := (Smalltalk allClasses collect: [:each | each category asString]) asSet asSortedCollection.
    ^ { #namespaces -> names } asDictionary
#+END_SRC
*** get classes of one namespace
#+BEGIN_SRC st :type method :name classes :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
classes: namespace
    | resultList |
    resultList := Smalltalk allClasses select: [:each | each category asString = namespace].
    ^ { #classes -> (resultList collect: [:each | each name asString])} asDictionary
#+END_SRC
*** get class information
#+BEGIN_SRC st :type method :name classDef: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
classDef: className
	| class instanceSide classSide result |
	class := Smalltalk at: className asSymbol.
	instanceSide := Dictionary new.
	instanceSide at: #class put: className.
	instanceSide at: #superclass put: (class superclass printString).
	instanceSide at: #instvars put: (class instVarNames asStringArray).
	instanceSide at: #classvars put: (class classVarNames asStringArray).
	instanceSide at: #poolvars put: (class sharedPools asStringArray).

	class := class class.
	classSide := Dictionary new.
	classSide at: #class put: className.
	classSide at: #superclass put: (class superclass printString).
	classSide at: #instvars put: (class instVarNames asStringArray).
	classSide at: #classvars put: (class classVarNames asStringArray).
	classSide at: #poolvars put: (class sharedPools asStringArray).
        result := Dictionary new.
	result at: #instance put: instanceSide.
	result at: #class put: classSide.
	^ result
#+END_SRC
*** get class categories
#+BEGIN_SRC st :type method :name classCats: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
classCats: className
    | class cats instanceSide classSide |
    result := Dictionary new.
    class := Smalltalk at: className asSymbol.
    cats := Set new.
    class methodDictionary ifNotNil: [:d | d values do:
	[:each | cats add: each category]].

    result at: #instance put: cats.

    class := class class.
    cats := Set new.
    class methodDictionary ifNotNil: [:d | d values do:
	[:each | cats add: each category]].
    result at: #class put: cats.
    ^ result
#+END_SRC

*** get methods in one class category
#+BEGIN_SRC st :type method :name catMethods: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
catMethods: className category: cat side: side
            | class methods allMethods result |
            class := Smalltalk at: className asSymbol.
            (side = #class) ifTrue: [class := class class].

            allMethods := class methodDictionary ifNil: [#()] ifNotNil: [:x | x associations].

            methods := (cat = '*'
                ifTrue: [allMethods]
                ifFalse: [allMethods select: [:e | e value category = cat]]).
	   ^ { #methods -> (methods collect: [:each | each key asString]) asSortedCollection } asDictionary
#+END_SRC

*** get method source
#+BEGIN_SRC st :type method :name methodSource: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
methodSource: className name: name side: side
	| class method |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].
	method := class methodDictionary at: name asSymbol.
	^ {#source -> method sourceCode} asDictionary
#+END_SRC
*** get method source
#+BEGIN_SRC st :type method :name methodSource: :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
evalCode: code
    | status result |
    status  := #success.
    result := [OpalCompiler new source: code; evaluate] onErrorDo:  [ result := #failed ].
    ^ {#result -> result. #status -> status} asDictionary
#+END_SRC


*** compile method
#+BEGIN_SRC st :type method :name compileMethod :class LiterateServer :side class :cat "accessing" :ns LiterateSmalltalk
compileMethod: className source: source side: side
	| class result |
	class := (Smalltalk at: className asSymbol).
	(side = #class) ifTrue: [class := class class].

	result := #success.
	[class compile: source] onErrorDo: [ result := #failed ].
	^ {#result -> result} asDictionary
#+END_SRC
