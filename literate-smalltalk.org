# -*- encoding:utf-8 Mode: POLY-ORG; tab-width: 2; org-src-preserve-indentation: t; -*- ---
#+TITLE:  Literate programming tool write smalltalk in org mode.
#+SubTitle: inspired by shampoo.
#+OPTIONS: toc:2
#+Startup: noindent
#+PROPERTY: header-args :results silent
#+LATEX_HEADER: % copied from lstlang1.sty, to add new language support to Emacs Lisp.
#+LATEX_HEADER: \lstdefinelanguage{elisp}[]{lisp} {}
#+LATEX_HEADER: \lstloadlanguages{elisp}
#+PROPERTY: header-args
#+PROPERTY: literate-load yes
#+PROPERTY: literate-class LiterateServer
* Table of Contents                                            :TOC:noexport:
- [[#introduction][Introduction]]
- [[#preparation][Preparation]]
- [[#how-to-do-it-04][How to do it?]]
- [[#a-minor-mode-for-source-code][a minor mode for source code]]
- [[#utilities][utilities]]
  - [[#valid-side][valid side]]
  - [[#forward-to-begin-of-function][forward to begin of function]]
  - [[#current-symbol-at-point][current symbol at point]]
  - [[#previous-symbol-at-point][previous symbol at point]]
  - [[#check-autogenerated-code][check autogenerated code]]
  - [[#api-request][api request]]
- [[#baseline-for-pharo][baseline for pharo]]
  - [[#definition][definition]]
  - [[#spec][spec]]
- [[#a-teapot-server-to-handle-request][a Teapot server to handle request]]
  - [[#definition-1][definition]]
  - [[#the-server-accessor][the Server accessor]]
    - [[#reader][reader]]
    - [[#writer][writer]]
  - [[#routes][routes]]
  - [[#utils][utils]]
    - [[#asstringarray][asStringArray:]]
    - [[#elementsstring][elementsString]]
- [[#namespace][namespace]]
  - [[#namespaces][namespaces]]
    - [[#emacs][Emacs]]
    - [[#pharo][pharo]]
    - [[#cache-relationship-between-namespace-and-class][cache relationship between namespace and class]]
    - [[#get-namespace-of-one-class][get namespace of one class]]
  - [[#classes-for-one-namespace][classes for one namespace]]
    - [[#emacs-1][Emacs]]
    - [[#pharo-1][Pharo]]
- [[#package][package]]
- [[#class][class]]
  - [[#emacs-2][Emacs]]
    - [[#print-out-class-definition][print out class definition]]
    - [[#get-class-definition][get class definition]]
    - [[#get-categories-of-one-class][get categories of one class]]
    - [[#get-methods-of-one-category][get methods of one category]]
    - [[#get-method-source][get method source]]
  - [[#pharo-2][Pharo]]
    - [[#class-definition][class definition]]
    - [[#get-class-categories][get class categories]]
    - [[#get-methods-in-one-class-category][get methods in one class category]]
    - [[#get-method-source-1][get method source]]
- [[#eval-code][eval code]]
  - [[#emacs-3][Emacs]]
  - [[#pharo-3][Pharo]]
- [[#compile][compile]]
  - [[#emacs-4][Emacs]]
    - [[#parse-a-regex][parse a regex]]
    - [[#how-to-parse-a-class-message][how to parse a class message]]
    - [[#parse-class-definition][parse class definition]]
    - [[#parse-subclass-definition][parse subclass definition]]
    - [[#compile-class][compile class]]
    - [[#compile-method][compile method]]
    - [[#api-request-to-format-code][API request to format code]]
  - [[#command-to-code-format][command to code format]]
  - [[#pharo-4][Pharo]]
    - [[#compile-class-1][compile class]]
    - [[#compile-method-1][compile method]]
    - [[#format-code][format code]]
- [[#code-navigation][Code navigation]]
  - [[#search-a-pattern-in-a-buffer-and-return-its-position][search a pattern in a buffer and return its position]]
  - [[#find-definition-of-class-in-org-files][find definition of class in org files]]
  - [[#find-definition-of-a-class-method-in-org-files][find definition of a class method in org files]]
  - [[#get-method-name-from-method-codes][get method name from method codes]]
  - [[#basic-idea][basic idea]]
  - [[#xref-interfaces][xref interfaces]]
  - [[#implementation][implementation]]
- [[#update-source][Update source]]
- [[#import-codes-of-namespaces-to-org-mode][Import codes of namespaces to org mode]]
- [[#babel-support][babel support]]
  - [[#optionally-define-a-file-extension-for-this-language][optionally define a file extension for this language]]
  - [[#optionally-declare-default-header-arguments][optionally declare default header arguments]]
  - [[#source-code-execution][Source Code Execution]]
    - [[#babel-entry][babel entry]]
    - [[#implementation-1][implementation]]
  - [[#execute-all-source-codes-in-current-header][execute all source codes in current header]]
- [[#shortcut][shortcut]]
- [[#test][Test]]
  - [[#eval-codes][eval codes]]

* Introduction
This is an attemp to write smalltalk codes in org mode,
and interact with remote [[https://pharo.org/][pharo]] images inspired from [[https://github.com/dmatveev/shampoo-emacs][shampoo]]([[https://github.com/jingtaozf/shampoo-pharo.git][shampo for pharo]]).
* Preparation
You need to install pharo side codes in pharo and start server by the following codes
#+begin_src st
LiterateServer start.
#+end_src
* How to do it? [0/4]
We interact with pharo via shampoo, and hack shampoo to fetch/update codes in an org file.

- [ ] Find packages's sub category
https://github.com/pharo-open-documentation/pharo-wiki/blob/master/General/Extensions.md#define-an-extension-method-programmatically
- [ ] Find package's extensions
(RPackageOrganizer default packageMatchingExtensionName: #packagename) metaclassExtensionSelectors .
* a minor mode for source code
inspired from shampoo-code-mode
#+BEGIN_SRC elisp
(defconst literate-smalltalk-smalltalk-binsel "\\([-+*/~,<>=&?]\\{1,2\\}\\|:=\\|||\\)"
"Smalltalk binary selectors")

(defconst literate-smalltalk-smalltalk-font-lock-keywords
(list
'("#[A-z][A-z0-9_]*"          . font-lock-constant-face)
'("\\<[A-z][A-z0-9_]*:"       . font-lock-function-name-face)
(cons literate-smalltalk-smalltalk-binsel 'font-lock-function-name-face)
'("\\$."                      . font-lock-string-face)
'("\\<[A-Z]\\sw*\\>"          . font-lock-type-face)
'("[0-9]+"                    . font-lock-constant-face))
"Basic Smalltalk keywords font-locking")

(defconst literate-smalltalk-smalltalk-font-lock-keywords-1
literate-smalltalk-smalltalk-font-lock-keywords
"Level 1 Smalltalk font-locking keywords")

(defconst literate-smalltalk-smalltalk-font-lock-keywords-2
(append literate-smalltalk-smalltalk-font-lock-keywords-1
(list
		'("\\<\\(true\\|false\\|nil\\|self\\|super\\)\\>"
		. font-lock-builtin-face)
		'(":[a-z][A-z0-9_]*" . font-lock-variable-name-face)
		'(" |"               . font-lock-type-face)
		'("<.*>"             . font-lock-builtin-face)))
"Level 2 Smalltalk font-locking keywords")

(defconst literate-smalltalk-smalltalk-font-lock-keywords-list
'((literate-smalltalk-smalltalk-font-lock-keywords
		literate-smalltalk-smalltalk-font-lock-keywords-1
		literate-smalltalk-smalltalk-font-lock-keywords-2)))

(defvar literate-smalltalk-smalltalk-mode-syntax-table
(let ((table (make-syntax-table)))
;; Make sure A-z0-9 are set to "w   " for completeness
(let ((c 0))
		(setq c ?0)
		(while (<= c ?9)
(setq c (1+ c))
(modify-syntax-entry c "w   " table))
		(setq c ?A)
		(while (<= c ?Z)
(setq c (1+ c))
(modify-syntax-entry c "w   " table))
		(setq c ?a)
		(while (<= c ?z)
(setq c (1+ c))
(modify-syntax-entry c "w   " table)))
(modify-syntax-entry 10  " >  " table) ; Comment (generic)
(modify-syntax-entry ?:  ".   " table) ; Symbol-char
(modify-syntax-entry ?_  "_   " table) ; Symbol-char
(modify-syntax-entry ?\" "!1  " table) ; Comment (generic)
(modify-syntax-entry ?'  "\"  " table) ; String
(modify-syntax-entry ?#  "'   " table) ; Symbol or Array constant
(modify-syntax-entry ?\( "()  " table) ; Grouping
(modify-syntax-entry ?\) ")(  " table) ; Grouping
(modify-syntax-entry ?\[ "(]  " table) ; Block-open
(modify-syntax-entry ?\] ")[  " table) ; Block-close
(modify-syntax-entry ?{  "(}  " table) ; Array-open
(modify-syntax-entry ?}  "){  " table) ; Array-close
(modify-syntax-entry ?$  "/   " table) ; Character literal
(modify-syntax-entry ?!  ".   " table) ; End message / Delimit defs
(modify-syntax-entry ?\; ".   " table) ; Cascade
(modify-syntax-entry ?|  ".   " table) ; Temporaries
(modify-syntax-entry ?^  ".   " table) ; Return
;; Just to make sure these are not set to "w   "
(modify-syntax-entry ?<  ".   " table)
(modify-syntax-entry ?>  ".   " table)
(modify-syntax-entry ?+  ".   " table) ; math
(modify-syntax-entry ?-  ".   " table) ; math
(modify-syntax-entry ?*  ".   " table) ; math
(modify-syntax-entry ?/  ".2  " table) ; math
(modify-syntax-entry ?=  ".   " table) ; bool/assign
(modify-syntax-entry ?%  ".   " table) ; valid selector
(modify-syntax-entry ?&  ".   " table) ; boolean
(modify-syntax-entry ?\\ ".   " table) ; ???
(modify-syntax-entry ?~  ".   " table) ; misc. selector
(modify-syntax-entry ?@  ".   " table) ; Point
(modify-syntax-entry ?,  ".   " table) ; concat
table)
"Syntax table used by Smalltalk mode")

(define-derived-mode literate-smalltalk-code-mode
text-mode "Literate Smalltalk code"
(set (make-local-variable 'font-lock-defaults)
				literate-smalltalk-smalltalk-font-lock-keywords-list)
(set (make-local-variable 'comment-start) "\"")
(set (make-local-variable 'comment-end) "\"")
(set-syntax-table literate-smalltalk-smalltalk-mode-syntax-table))

(setq auto-mode-alist (append '(("\\.st\\'" . literate-smalltalk-code-mode)) auto-mode-alist))
#+END_SRC

* utilities
** valid side
#+BEGIN_SRC elisp
(defvar literate-smalltalk-valid-sides '(:class :instance))
(defun literate-smalltalk-side-sym-as-param (sym)
  (cdr (assoc sym '((:instance . "instance")
                    (:class    . "class")))))
#+END_SRC
** forward to begin of function
#+BEGIN_SRC elisp
(defun literate-smalltalk-beginning-of-defun-function (arg)
  (if (> arg 0)
    (progn
      (search-backward "#+BEGIN_SRC ")
      (forward-line))
    (literate-smalltalk-end-of-defun-function)))

(defun literate-smalltalk-end-of-defun-function (arg)
  (search-forward "#+END_SRC")
  (forward-line -1))

(defun install-literate-smalltalk-beginning-of-defun-function ()
  (make-local-variable 'beginning-of-defun-function)
  (make-local-variable 'end-of-defun-function)
  (setf beginning-of-defun-function 'literate-smalltalk-beginning-of-defun-function)
  (setf end-of-defun-function 'literate-smalltalk-end-of-defun-function)
  )
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-beginning-of-defun-function)
#+END_SRC
** current symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-current-symbol-at-point ()
  (save-excursion
    (let* ((beg (re-search-backward "[ \t\n\r(^[]" nil t))
           (end (progn
                  (forward-char)
                  (re-search-forward "[ \t\n\r\.]" nil t)
                  (backward-char)
                  (point))))
      (string-trim (buffer-substring-no-properties beg end) "[ \t\n\r(^]+"))))
#+END_SRC
** previous symbol at point
#+BEGIN_SRC elisp
(defun literate-smalltalk-previous-symbol-at-point ()
  (save-excursion
    (re-search-backward "[ \t\n\r]" nil t)
    (forward-word -1)
    (literate-smalltalk-current-symbol-at-point)))
#+END_SRC
** check autogenerated code
#+BEGIN_SRC elisp
(defun literate-smalltalk-autogenerated-code? (code)
  (search "\"Autogenerated " source))
#+END_SRC
** api request
#+BEGIN_SRC elisp
(defvar literate-smalltalk-rest-server "http://localhost:9092/")
(defvar literate-smalltalk-last-response nil)
(cl-defun literate-smalltalk-request (path &key params data (type "GET"))
  (let ((resp nil))
    (request (concat literate-smalltalk-rest-server path)
        :params params
        :parser 'json-read
        :type type
        :sync t
        :data data
        :complete (cl-function
                   (lambda (&key response &allow-other-keys)
                     (setf literate-smalltalk-last-response response)
                     (unless (equal 200 (request-response-status-code response))
                       (error "Failed to request to remote pharo:%s" response))
                     (setf resp (request-response-data response)))))
    resp))
#+END_SRC
* baseline for pharo
:PROPERTIES:
:literate-class: BaselineOfLiterateSmalltalk
:END:
** definition
#+BEGIN_SRC smalltalk
"
Baseline of LiterateSmalltalk.
"
BaselineOf subclass: #BaselineOfLiterateSmalltalk
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'BaselineOfLiterateSmalltalk'
----------------------
BaselineOfLiterateSmalltalk class
    instanceVariableNames: ''
#+END_SRC
** spec
#+BEGIN_SRC smalltalk :cat "baseline"
baselineOf: spec

	<baseline>
	spec for: #common do: [
		spec
			baseline: 'Teapot' with: [
				spec
					repository: 'github://zeroflag/Teapot:v2.6.0/source';
					loads: #( 'Deployment' ) ];
			import: 'Teapot'.
		spec
			package: 'LiterateSmalltalk'
			with: [ spec requires: #( 'Teapot' ) ].
		spec group: 'default' with: #( 'LiterateSmalltalk' ) ]
#+END_SRC
* a Teapot server to handle request
** definition
#+BEGIN_SRC smalltalk
"
The REST Server for LiterateSmalltalk.
"
Object subclass: #LiterateServer
    instanceVariableNames: ''
    classVariableNames: 'Server Started'
    package: 'LiterateSmalltalk'
----------------------
LiterateServer class
    instanceVariableNames: ''
#+END_SRC
** the Server accessor
*** reader
#+BEGIN_SRC smalltalk :type method :name server :side class :cat "accessing" :ns LiterateSmalltalk
server
	"returns teapot instance"
	^ Server
#+END_SRC
*** writer
#+BEGIN_SRC smalltalk :type method :name server: :side class :cat "accessing" :ns LiterateSmalltalk
server: server
	"sets teapot for class"
	Server := server.
#+END_SRC
** routes
#+BEGIN_SRC smalltalk :type method :name start :side class :cat "management" :ns LiterateSmalltalk
start

	"Start the webserver"

	| teapot |
	"extra check so that we don't close a Pool which wasn't open"
	Started ifNotNil: [ Server stop ].
	teapot := Teapot configure: {
			          (#defaultOutput -> #json).
			          (#port -> 9092).
			          (#debugMode -> true).
			          (#bindAddress -> #[ 127 0 0 1 ]) }.
	teapot server logLevel: 1.
	self server: teapot.
	teapot
		GET: '/namespaces' -> [ :req | self namespaces ];
		GET: '/classes/<namespace>'
			-> [ :req | self classes: (req at: #namespace) ];
		GET: '/class/<class>' -> [ :req | self classDef: (req at: #class) ];
		GET: '/cats/<class>' -> [ :req | self classCats: (req at: #class) ];
		GET: '/cat/methods' -> [ :req |
				self
					catMethods: (req at: #class)
					category: (req at: #cat)
					side: (req at: #side) ];
		GET: '/method/source' -> [ :req |
				self
					methodSource: (req at: #class)
					name: (req at: #name)
					side: (req at: #side) ];
		POST: '/eval' -> [ :req | self evalCode: (req at: #code) ];
		POST: '/compile/class' -> [ :req |
				self
					compileClass: (NeoJSONReader fromString: (req at: #instance))
					class: (NeoJSONReader fromString: (req at: #class)) ];
		POST: '/compile/method' -> [ :req |
				self
					compileMethod: (req at: #class)
					category: (req at: #category)
					source: (req at: #source)
					side: (req at: #side) ];
		POST:
			'/format/code' -> [ :req | self formatCode: (req at: #source) ];
		exception:
			KeyNotFound -> (TeaResponse notFound body: 'No such method');
		start.

	Started := true
#+END_SRC

** utils
*** asStringArray:
Many reflection methods return different results in various dialects.
=#instVarNames= in GNU Smalltalk returns an IdentitySet of Symbols, the
same method returns an Array of Strings in Squeak

This kludge works as an abstraction over it all
#+BEGIN_SRC smalltalk :type method :side class :cat "utilities" :ns LiterateSmalltalk
asStringArray: items

	^ (items collect: [ :each | each asString ]) asArray
#+END_SRC
*** elementsString
#+BEGIN_SRC smalltalk :type method :side class :cat "utilities" :ns LiterateSmalltalk
elementsString: items

	^ items inject: '' into: [ :acc :each | acc , each asString , ' ' ]
#+END_SRC

* namespace
** namespaces
*** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespaces ()
  (cdr (assoc 'namespaces (literate-smalltalk-request "namespaces"))))

(defun literate-smalltalk-select-namespace ()
  (helm-select-list "Please select a namespace: " (literate-smalltalk-namespaces)))
#+END_SRC
*** pharo
#+BEGIN_SRC smalltalk :type method :name namespaces :side class :cat "accessing" :ns LiterateSmalltalk
namespaces

	| names |
	names := (Smalltalk globals allClasses collect: [ :each |
		          each category asString ]) asSet asSortedCollection.
	^ { (#namespaces -> names) } asDictionary
#+END_SRC
*** cache relationship between namespace and class
It is slow to build such indexed from remote pharo, let store it to a global variable and cache it to local file.
#+BEGIN_SRC elisp
(defvar literate-smalltalk-indexed-classes-file "~/.emacs.d/smalltalk.classes.txt")
(defvar literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
(defun literate-smalltalk-index-classes ()
  (interactive)
  (loop for namespace in (literate-smalltalk-namespaces)
        do (message "Indexing %s" namespace)
           (loop for class in (literate-smalltalk-classes namespace)
                 do (setf (gethash class literate-smalltalk-indexed-classes) namespace)))
  (with-current-buffer (find-file-noselect literate-smalltalk-indexed-classes-file)
    (erase-buffer)
    (fundamental-mode)
    (maphash (lambda (k v)
               (insert k " " v "\n"))
             literate-smalltalk-indexed-classes)
    (save-buffer)
    (kill-current-buffer)))

(defun literate-smalltalk-restore-indexed-classes ()
  (interactive)
  (message "start restoring...")
  (setf literate-smalltalk-indexed-classes (make-hash-table :test 'equal))
  (cl-loop for line in (s-split "\n" (f-read literate-smalltalk-indexed-classes-file) t)
           for items = (s-split " " line)
           do (setf (gethash (car items) literate-smalltalk-indexed-classes) (second items)))
  (message "restoring...done"))
#+END_SRC
*** get namespace of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-of-a-class (class)
  (when (= 0 (hash-table-count literate-smalltalk-indexed-classes))
    (error "Please build the cache before use namespace of a class."))
  (gethash class literate-smalltalk-indexed-classes))

(defun literate-smalltalk-namespace-of-current-symbol ()
  (interactive)
  (let ((class (thing-at-point 'symbol)))
    (message "%s's namespace is %s" class (literate-smalltalk-namespace-of-a-class class))))
#+END_SRC


** classes for one namespace
*** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-classes (namespace)
  (mapcar 'identity
          (cdr (assoc 'classes (literate-smalltalk-request (concat "classes/" namespace))))))

(defun literate-smalltalk-select-a-class (namespace)
  (helm-select-list "Please select a namespace: " (literate-smalltalk-classes namespace)))
#+END_SRC
*** Pharo
#+BEGIN_SRC smalltalk :type method :name classes :side class :cat "accessing" :ns LiterateSmalltalk
classes: namespace

	| resultList |
	resultList := Smalltalk globals allClasses select: [ :each |
		              each category asString = namespace ].
	^ { (#classes -> (resultList collect: [ :each | each name asString ])) }
		  asDictionary
#+END_SRC

* package
* class
** Emacs
*** print out class definition
#+BEGIN_SRC elisp
(defconst literate-smalltalk-class-template
  '(("instanceVariableNames:" . instvars)
    ("classVariableNames:"    . classvars)
    ;; ("poolDictionaries:"      . poolvars)
    ))

(defconst literate-smalltalk-class-side-template
  '(("instanceVariableNames:" . instvars)))
(defvar literate-smalltalk-separator "----------------------")

(defun literate-smalltalk-class-definition-string (resp)
  (let ((instance (cdr (assoc 'instance resp)))
        (class (cdr (assoc 'class resp))))
    (with-temp-buffer
      (insert "\"")
      (newline)
      (insert (cdr (assoc 'comment instance)))
      (newline)
      (insert "\"")
      (newline)
      (insert
       (format "%s subclass: #%s"
               (cdr (assoc 'superclass instance))
               (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (insert (format
               "    package: '%s'"
               (cdr (assoc 'package instance))))
      (newline)
      (insert literate-smalltalk-separator)
      (newline)

      (insert (format "%s class" (cdr (assoc 'class class))))
      (newline)
      (dolist (each literate-smalltalk-class-side-template)
        (let* ((items (cdr (assoc (cdr each) instance)))
               (text  (string-join items " ")))
          (insert (format "    %s '%s'"  (car each) text))
          (newline)))
      (trim-string (buffer-string)))))
#+END_SRC
*** get class definition
#+BEGIN_SRC elisp
(defun literate-smalltalk-class (class)
  (literate-smalltalk-class-definition-string (literate-smalltalk-request (concat "class/" class))))
#+END_SRC
*** get categories of one class
#+BEGIN_SRC elisp
(defun literate-smalltalk-categories (class)
  (literate-smalltalk-request (concat "cats/" class)))

;; (defun literate-smalltalk-select-a-category (namespace class)
;;   (helm-select-list "Please select a namespace: " (literate-smalltalk-categories namespace class)))
#+END_SRC
*** get methods of one category
#+BEGIN_SRC elisp
(defun literate-smalltalk-category-methods (class category side)
  (mapcar 'identity
          (cdr (assoc 'methods (literate-smalltalk-request "cat/methods"
                                                           :params `(("class" . ,class)
                                                                     ("cat" . ,category)
                                                                     ("side" . ,side)))))))
#+END_SRC
*** get method source
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-source (class method side)
  (let ((source (cdr (assoc 'source (literate-smalltalk-request
                                     "method/source"
                                     :params `(("class" . ,class)
                                               ("name" . ,method)
                                               ("side" . ,side)))))))
    (decode-coding-string source 'latin-1-mac)))
#+END_SRC
** Pharo
*** class definition
#+BEGIN_SRC smalltalk :type method :name classDef: :side class :cat "accessing" :ns LiterateSmalltalk
classDef: className

	| class instanceSide classSide result |
	class := Smalltalk at: className asSymbol.
	instanceSide := Dictionary new.
	instanceSide at: #class put: className.
	instanceSide at: #superclass put: class superclass printString.
	instanceSide
		at: #instvars
		put: (self asStringArray: class instVarNames).
	instanceSide
		at: #classvars
		put: (self asStringArray: class classVarNames).
	instanceSide
		at: #poolvars
		put: (self asStringArray: class sharedPools).
	instanceSide at: #package put: class category.
	instanceSide at: #comment put: class comment.

	class := class class.
	classSide := Dictionary new.
	classSide at: #class put: className.
	classSide at: #superclass put: class superclass printString.
	classSide at: #instvars put: (self asStringArray: class instVarNames).
	classSide
		at: #classvars
		put: (self asStringArray: class classVarNames).
	classSide at: #poolvars put: (self asStringArray: class sharedPools).
	result := Dictionary new.
	result at: #instance put: instanceSide.
	result at: #class put: classSide.
	^ result
#+END_SRC
*** get class categories
#+BEGIN_SRC smalltalk :type method :name classCats: :side class :cat "accessing" :ns LiterateSmalltalk
classCats: className

	| class cats result |
	result := Dictionary new.
	class := Smalltalk at: className asSymbol.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d |
		d values do: [ :each | cats add: each category ] ].

	result at: #instance put: cats.

	class := class class.
	cats := Set new.
	class methodDictionary ifNotNil: [ :d |
		d values do: [ :each | cats add: each category ] ].
	result at: #class put: cats.
	^ result
#+END_SRC
*** get methods in one class category
#+BEGIN_SRC smalltalk :type method :name catMethods: :side class :cat "accessing" :ns LiterateSmalltalk
catMethods: className category: cat side: side

	| class methods allMethods |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	allMethods := class methodDictionary
		              ifNil: [ #(  ) ]
		              ifNotNil: [ :x | x associations ].

	methods := cat = '*'
		           ifTrue: [ allMethods ]
		           ifFalse: [
		           allMethods select: [ :e | e value category = cat ] ].
	^ { (#methods
	   ->
	   (methods collect: [ :each | each key asString ])
		   asSortedCollection) } asDictionary
#+END_SRC
*
*** get method source
#+BEGIN_SRC smalltalk :type method :name methodSource: :side class :cat "accessing" :ns LiterateSmalltalk
methodSource: className name: name side: side

	| class method |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].
	method := class methodDictionary at: name asSymbol.
	^ { (#source -> method sourceCode) } asDictionary
#+END_SRC

* eval code
** Emacs
#+BEGIN_SRC elisp
(defun literate-smalltalk-eval (code)
  (let ((resp (literate-smalltalk-request
                                     "eval"
                                     :type "POST"
                                     :params `(("code" . ,code)))))
    (if (string= "success" (cdr (assoc 'status resp)))
      (cdr (assoc 'result resp))
      (error "Failed to eval code!"))))
#+END_SRC
** Pharo
#+BEGIN_SRC smalltalk :type method :name methodSource: :side class :cat "compile" :ns LiterateSmalltalk
evalCode: code

	| status result |
	status := #success.
	result := [
	          OpalCompiler new
		          source: code;
		          evaluate ] on: Error do: [ result := #failed ].
	^ {
		  (#result -> result).
		  (#status -> status) } asDictionary
#+END_SRC

* compile
** Emacs
*** parse a regex
#+BEGIN_SRC elisp
(defvar literate-smalltalk-regexp-tokens
    '((:Wd "\\([A-z]+[0-9]*\\)")
      (:Ws "\\([A-z 0-9]*\\)")
      (:Wa "\\([A-z\\.0-9]*\\)")
      (:Wc "\\([A-z\-0-9]*\\)")
      (:D  "\\([0-9]*\\)")
      (:sp "[ \s\t\n\r]*")
      (:cr "\r")
      (:lf "\n")))

(defun literate-smalltalk-regexp-is-capture-token (sym)
  (let ((pattern (assoc sym literate-smalltalk-regexp-tokens)))
    (and (symbolp sym)
         pattern
         (string-match "^\\\\\(.*\\\\\)$" (cadr pattern)))))

(defun literate-smalltalk-regexp-parse (str pattern)
  (let ((regexp (reduce 'concat
                        (loop for each in pattern collect
                                                  (let ((re (assoc each literate-smalltalk-regexp-tokens)))
                                                    (if re (cadr re) each)))))
        (re-len (loop for each in pattern
                      sum (if (literate-smalltalk-regexp-is-capture-token each) 1 0))))
    (with-temp-buffer
      (insert str)
      (goto-char (point-min))
      (when (re-search-forward regexp nil t)
        (loop for i from 1 to re-len collect
              (match-string i))))))

(defun literate-smalltalk-regexp-parse-and-bind (str pattern bindings binder)
  (let ((parsed (literate-smalltalk-regexp-parse str pattern)))
    (when parsed
      (loop for binding in bindings for j from 0 do
        (funcall
          binder
          binding
          (nth j parsed)))
      t)))
#+END_SRC

*** how to parse a class message
#+BEGIN_SRC elisp
(cl-defun literate-smalltalk-parse-message (&key code pattern bindings to-split)
  (lexical-let ((data '()))
    (let* ((binder #'(lambda (key value)
                       (push (cons key value) data)))
           (%split-string #'(lambda (string)
                              (if (null string)
                                '()
                                (remove-if (lambda (x) (equal x "")) (split-string string "\s"))))))
      (if (literate-smalltalk-regexp-parse-and-bind code pattern bindings binder)
        (progn
          (dolist (k to-split)
            (let ((string (cdr (assoc k data))))
              (setf (cdr (assoc k data))
                      (if (null string) '()
                        (remove-if (lambda (x) (equal x "")) (funcall %split-string string))))))
          data)
        (progn (message "literate smalltalk: syntax error")
               nil)))))
#+END_SRC
*** parse class definition
#+BEGIN_SRC elisp
(defvar literate-smalltalk-class-side-pattern
    '(:Wd :sp "class" :sp "instanceVariableNames:" :sp "'" :Ws "'"))
(defun literate-smalltalk-parse-class-definition (code)
  (literate-smalltalk-parse-message
   :code code
   :pattern literate-smalltalk-class-side-pattern
   :bindings '(:name :instvars)
   :to-split '(:instvars)))
#+END_SRC

*** parse subclass definition
#+BEGIN_SRC elisp
(defvar literate-smalltalk-subclass-pattern
    '(:Wa :sp "subclass:" :sp "#" :Wd
      :sp "instanceVariableNames:" :sp "'" :Ws "'"
      :sp "classVariableNames:"    :sp "'" :Ws "'"
      ;; :sp "poolDictionaries:"      :sp "'" :Ws "'"
      :sp "package:"              :sp "'" :Wc "'"
      ))
(defun literate-smalltalk-parse-subclass-definition (code)
  (literate-smalltalk-parse-message
   :code code
   :pattern literate-smalltalk-subclass-pattern
   :bindings '(:super :name :instvars :classvars :package)
   :to-split '(:instvars :classvars)))
#+END_SRC

*** compile class
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-class (code)
  (let (comment instance-code class-code anchor-pos)
    (with-temp-buffer
      (insert code)
      (goto-char (point-min))
      (search-forward-regexp "^\"$")
      (setf anchor-pos (point))
      (search-forward-regexp "^\"$")
      (forward-line -1)
      (setf comment (buffer-substring-no-properties anchor-pos (line-end-position)))
      (forward-line 2)
      (setf anchor-pos (line-beginning-position))
      (search-forward literate-smalltalk-separator)
      (setf instance-code (buffer-substring-no-properties anchor-pos (line-beginning-position)))
      (setf class-code (buffer-substring-no-properties (line-end-position) (point-max))))
    (let* ((instance-data (literate-smalltalk-parse-subclass-definition instance-code))
           (class-data (literate-smalltalk-parse-class-definition class-code)))
      (unless instance-data
        (message "instance-code:'%s'" instance-code)
        (error "Failed to get subclass information."))
      (unless class-data
        (message "class-data: '%s'" class-code)
        (error "Failed to get class information."))
      (push (cons "comment" comment) instance-data)
      (let ((resp (literate-smalltalk-request
                   "compile/class"
                   :params `(("instance" . ,(json-encode instance-data))
                             ("class" . ,(json-encode class-data)))
                   :type "POST")))
        (message "Compile class %s." (cdr (assoc 'status resp)))))))
#+END_SRC
*** compile method
#+BEGIN_SRC elisp
(defun literate-smalltalk-compile-method (class side category code)
  (let ((resp (literate-smalltalk-request
               "compile/method"
               :params `(("class" . ,class)
                       ("category" . ,category)
                       ("source" . ,code)
                       ("side" . ,(literate-smalltalk-side-sym-as-param side)))
               :type "POST")))
    (message "Compile method %s." (cdr (assoc 'result resp)))
    ))
#+END_SRC
*** API request to format code
[[file:~/projects/smalltalk/pharo/src/Deprecated80/PluggableTextMorph.class.st::tree := RBParser parseMethod: source onError: \[ :msg :pos | ^ self \].][RBParser parseMethod]]
#+BEGIN_SRC elisp
(defun literate-smalltalk-format-code (code)
  (let ((resp (literate-smalltalk-request
               "format/code"
               :params `(("source" . ,(encode-coding-string code 'latin-1-mac)))
               :type "POST")))
    (unless (string= "success" (cdr (assoc 'status resp)))
      (error "Failed to format code at %s:%s!"
             (cdr (assoc 'pos resp))
             (cdr (assoc 'msg resp))))
    (decode-coding-string (cdr (assoc 'source resp)) 'latin-1-mac)))

#+END_SRC
** command to code format
#+BEGIN_SRC elisp
(defun literate-smalltalk-code-format-current-code-block ()
  (interactive)
  (let* ((block-info (second (org-element-context)))
         (code (plist-get block-info :value))
         (formatted-code (literate-smalltalk-format-code code)))
    (replace-region-contents
     (plist-get block-info :begin)
     (plist-get block-info :end)
     (lambda ()
       (let* ((beg-src-line (progn (goto-char (point-min))
                                   (buffer-substring-no-properties
                                    (line-beginning-position)
                                    (line-end-position)))))
         (concat beg-src-line "\n"
                 formatted-code "\n"
                 "#+END_SRC\n"))))
    (message "format code done.")))
#+END_SRC


** Pharo
*** compile class
#+BEGIN_SRC smalltalk :type method :name compileMethod :side class :cat "compile" :ns LiterateSmalltalk
compileClass: instDef class: classDef

	| parent class status instvars classvars |
	status := #success.
	instvars := ''.
	(instDef at: #instvars) ifNotNil: [
		instvars := self elementsString: (instDef at: #instvars) ].

	classvars := ''.
	(instDef at: #classvars) ifNotNil: [
		classvars := self elementsString: (instDef at: #classvars) ].

	"Looks a bit kludgy, but currently I dont know how to make it better. TODO: refactor"
	parent := Smalltalk at: (instDef at: #super) asSymbol.
	[
	class := parent
		         subclass: (instDef at: #name) asSymbol
		         instanceVariableNames: instvars
		         classVariableNames: classvars
		         poolDictionaries: ''
		         category: (instDef at: #package) ]
		on: Error
		do: [ :e |
			Transcript
				show: e printString;
				cr.
			status := #failed ].

	class := Smalltalk at: (instDef at: #name) asSymbol ifAbsent: [ nil ].
	class comment: (instDef at: #comment).
	"On Pharo, there were a strange exception when using the safe form."
	instvars := ''.
	(classDef at: #instvars) ifNotNil: [
		instvars := self elementsString: (classDef at: #instvars) ].
	class class instanceVariableNames: instvars.

	^ { (#status -> status) } asDictionary
#+END_SRC
*** compile method
#+BEGIN_SRC smalltalk :type method :name compileMethod :side class :cat "compile" :ns LiterateSmalltalk
compileMethod: className category: cat source: source side: side

	| class result |
	class := Smalltalk at: className asSymbol.
	side = #class ifTrue: [ class := class class ].

	result := #success.
	[ class compile: source classified: cat ] on: Error do: [ result := #failed ].
	^ { (#result -> result) } asDictionary
#+END_SRC
*** format code
#+BEGIN_SRC smalltalk :type method :side class :cat "compile"
formatCode: source

	| tree |
	tree := RBParser
		        parseMethod: source
		        onError: [ :msg :pos |
		        ^ { #status -> #failed. #msg -> msg. #pos -> pos } asDictionary ].
	^ {
		  (#status -> #success).
		  (#source -> tree formattedCode) } asDictionary
#+END_SRC

* Code navigation
** search a pattern in a buffer and return its position
#+BEGIN_SRC elisp
(defvar literate-smalltalk-libraries-literate-path "~/Pharo/literate/")
(defun literate-smalltalk-search-pattern (pattern)
  (save-restriction
    (loop for buf in (cons (current-buffer)
                           (mapcar 'find-file-noselect (directory-files literate-smalltalk-libraries-literate-path t ".org$")))
          do (with-current-buffer buf
               (save-excursion
                 (goto-char (point-min))
                 (when (re-search-forward pattern nil t)
                   (goto-char (line-beginning-position))
                   (org-ensure-point-visible)
                   (return (list (current-buffer) (point)))))))))
#+END_SRC
** find definition of class in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-class-definition (class-name)
  (literate-smalltalk-search-pattern (format "subclass: #%s" class-name)))
#+END_SRC
** find definition of a class method in org files
#+BEGIN_SRC elisp
(defun literate-smalltalk-find-method-definition (class-name method-name)
  (literate-smalltalk-search-pattern (format ":class %s.*[\n\r]%s" class-name method-name)))
#+END_SRC
** get method name from method codes
#+BEGIN_SRC elisp
(defun literate-smalltalk-method-name-from-source (source)
  (let* ((first-line (first (split-string body "[\n\r]+" t nil)))
         (items (split-string first-line "[ \t]+" t "[ \t]+")))
    (if (= 1 (length items))
      (first items)
      (with-temp-buffer
        (loop for item in items
              if (search ":" item)
                do (insert item))
        (buffer-string)))))
#+END_SRC
** basic idea
We will try to use [[http://geoff.greer.fm/ag/][silver searcher]] as the xref backend to search.
#+BEGIN_SRC elisp
(defun literate-smalltalk-xref-backend ()
  'xref-st)

(defun install-literate-smalltalk-xref-backend ()
  (make-local-variable 'xref-backend-functions)
  (setf xref-backend-functions '(literate-smalltalk-xref-backend)))
(add-hook 'literate-smalltalk-code-mode-hook 'install-literate-smalltalk-xref-backend)
#+END_SRC
** xref interfaces
#+BEGIN_SRC elisp
(cl-defmethod xref-backend-identifier-at-point ((_backend (eql xref-st)))
  (literate-smalltalk-current-symbol-at-point))

(cl-defmethod xref-backend-definitions ((_backend (eql xref-st)) symbol)
  (literate-smalltalk--xref-find-definitions symbol))
#+END_SRC
** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk--xref-find-definitions (name)
  (interactive)
  (let* ((class? (<= ?A (aref name 0) ?Z))
         (class-name (unless class?
                       (literate-smalltalk-previous-symbol-at-point)))
         (buf-pos (if class?
                    (literate-smalltalk-find-class-definition name)
                    (literate-smalltalk-find-method-definition class-name name))))
    (when buf-pos
      (list (xref-make (if class?
                         name
                         (concat class-name ">>" name))
                       (xref-make-buffer-location (first buf-pos)
                                                (second buf-pos)))))))
#+END_SRC

* Update source
#+BEGIN_SRC elisp
(defun literate-smalltalk-update-source ()
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (body (nth 1 info))
         (params (nth 2 info))
         (type (if (cdr (assq :type params))
                 (intern (concat ":" (cdr (assq :type params))))
                 (if (search "subclass: #" body)
                   :class
                   :method)))
         (side (if (cdr (assq :side params))
                 (intern (concat ":" (cdr (assq :side params))))
                 :instance))
         (code (case type
                 (:method
                     (literate-smalltalk-method-source
                      (or (cdr (assq :class params))
                          (org-entry-get (point) "literate-class" t))
                      (literate-smalltalk-method-name-from-source body)
                      (literate-smalltalk-side-sym-as-param side)))
                 (:class
                  (literate-smalltalk-class
                   (or (cdr (assq :name params))
                       (org-entry-get (point) "literate-class" t))))
                 (t
                  (error "Unknown supported type %s" type))))
         (body (and code (decode-coding-string code 'latin-1-mac))))
    (when body
      (let ((block-info (second (org-element-context))))
        (replace-region-contents (plist-get block-info :begin)
                                 (plist-get block-info :end)
                                 (lambda ()
                                   (let* ((beg-src-line (progn (goto-char (point-min))
                                                               (buffer-substring-no-properties
                                                                (line-beginning-position)
                                                                (line-end-position)))))
                                     (concat beg-src-line "\n"
                                             body "\n"
                                             "#+END_SRC\n"))))
        (message "update source done.")))))
#+END_SRC
* Import codes of namespaces to org mode
#+BEGIN_SRC elisp
(defun literate-smalltalk-namespace-to-org-section (&optional namespaces)
  (interactive)
  (let ((namespaces (or namespaces (literate-smalltalk-select-namespace))))
    (unless (listp namespaces)
      (setf namespaces (list namespaces)))
    (cl-loop for namespace in namespaces
             do (newline)
             (insert "* PACKAGE " namespace)
             (newline)
             (loop for class in (literate-smalltalk-classes namespace)
                   for categories-dict = (literate-smalltalk-categories class)
                   do (insert "** CLASS " class)
                      (newline)
                      (insert ":PROPERTIES:")
                      (newline)
                      (insert ":literate-class:    " class)
                      (newline)
                      (insert ":END:")
                      (newline)
                      (insert "*** CLASS DEFINITION")
                      (newline)
                      (insert "#+BEGIN_SRC smalltalk")
                      (newline)
                      (insert (literate-smalltalk-class class))
                      (newline)
                      (insert "#+END_SRC")
                      (newline)
                      (loop for side in literate-smalltalk-valid-sides
                            for side-symbol = (intern (subseq (symbol-name side) 1))
                            for side-name = (literate-smalltalk-side-sym-as-param side)
                            do (loop for category across (cdr (assoc side-symbol categories-dict))
                                     for normalized-category = (replace-regexp-in-string
                                                                       " " "@" category)
                                     do (loop for method in (literate-smalltalk-category-methods
                                                                     class category side-name)
                                              for source = (literate-smalltalk-method-source
                                                                  class method side-name)
                                              if (not (literate-smalltalk-autogenerated-code? source))
                                              do (insert "*** METHOD "
                                                         method "                                            "
                                                                (symbol-name side)
                                                         ":" normalized-category ":")
                                                 (newline)
                                                 (insert "#+BEGIN_SRC smalltalk"
                                                         " :class " class
                                                         " :side " side-name
                                                         " :cat \"" category "\"")
                                                 (newline)
                                                 (insert source)
                                                 (newline)
                                                 (insert "#+END_SRC")
                                                 (newline)
                                                 (sit-for 0)))))
             (message "namedspace '%s' has been added." namespace))))
#+END_SRC
* babel support
** optionally define a file extension for this language
#+BEGIN_SRC elisp
(add-to-list 'org-babel-tangle-lang-exts '("smalltalk" . "smalltalk"))
#+END_SRC
** optionally declare default header arguments
#+BEGIN_SRC elisp
(defvar org-babel-default-header-args:smalltalk '())
#+END_SRC
** Source Code Execution
*** babel entry
This is the main function which is called to evaluate a code block.

This function will evaluate the body of the source code and
return the results as emacs-lisp depending on the value of the
=:results= header argument

All header arguments specified by the user will be available in the =PARAMS= variable.
#+BEGIN_SRC elisp
(defun org-babel-execute:smalltalk (body params)
  "Execute a block of smalltalk code with org-babel.
This function is called by `org-babel-execute-src-block',
Argument BODY: the code body
Argument PARAMS: the input parameters."
  (let* ((result-params (cdr (assq :result-params params)))
         (results (format "%s" (literate-smalltalk-execute-code-block body params))))
    (when results
      (org-babel-result-cond result-params
        results
        (let ((tmp-file (org-babel-temp-file "q-")))
          (with-temp-file tmp-file (insert results))
          (org-babel-import-elisp-from-file tmp-file))))))
#+END_SRC
*** implementation
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-code-block (body params)
  (let ((type (if (cdr (assq :type params))
                (intern (concat ":" (cdr (assq :type params))))
                (if (search "subclass: #" body)
                  :class
                  :method)))
        (side (if (cdr (assq :side params))
                (intern (concat ":" (cdr (assq :side params))))
                :instance))
        (code (encode-coding-string body 'latin-1-mac)))
    (case type
      (:code (literate-smalltalk-eval code))
      (:method
          (literate-smalltalk-compile-method
           (or (cdr (assq :class params))
               (org-entry-get (point) "literate-class" t))
           side
           (cdr (assq :cat params))
           code))
      (:class
       (literate-smalltalk-compile-class body))
      (t
       (error "Unknown type %s" type)))))
#+END_SRC
** execute all source codes in current header
#+BEGIN_SRC elisp
(defun literate-smalltalk-execute-current-header ()
  (interactive)
  (let* ((element (org-element-at-point))
         (info (second element))
         (begin (plist-get info :begin))
         (end (plist-get info :end)))
    (if current-prefix-arg
      (setf end (point-max))
      (unless (eq 'headline (first element))
        (error "Please move point to a headline.")))
    (save-excursion
      (goto-char begin)
      (while (search-forward "#+BEGIN_SRC smalltalk" end t)
        (unless (search ":type code" (buffer-substring-no-properties (line-beginning-position)
                                                                     (line-end-position)))
          (org-babel-execute-src-block-maybe))))))
#+END_SRC

* shortcut
#+BEGIN_SRC elisp
(define-quick-choice (literate-smalltalk-code-mode)
    ("package of class" literate-smalltalk-namespace-of-current-symbol)
  ("execute codes" org-babel-execute-src-block-maybe)
  ("compile codes" org-babel-execute-src-block-maybe)
  ("Compile codes in current header" literate-smalltalk-execute-current-header)
  ("format code" literate-smalltalk-code-format-current-code-block)
  ("update codes" literate-smalltalk-update-source)
  )
#+END_SRC

* Test
** eval codes
:PROPERTIES:
:results:  value
:END:
#+BEGIN_SRC smalltalk :type code :results raw
y := Dictionary new.
y at: 'page' put: '2'.
y
#+END_SRC
